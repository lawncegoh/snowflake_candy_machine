{"ast":null,"code":"import { TransactionInstruction } from \"@solana/web3.js\";\nimport { IdlError } from \"../../error\";\nimport { toInstruction, validateAccounts, translateAddress } from \"../common\";\nimport { splitArgsAndCtx } from \"../context\";\nexport default class InstructionNamespaceFactory {\n  static build(idlIx, encodeFn, programId) {\n    if (idlIx.name === \"_inner\") {\n      throw new IdlError(\"the _inner name is reserved\");\n    }\n\n    const ix = (...args) => {\n      const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\n      validateAccounts(idlIx.accounts, ctx.accounts);\n      validateInstruction(idlIx, ...args);\n      const keys = ix.accounts(ctx.accounts);\n\n      if (ctx.remainingAccounts !== undefined) {\n        keys.push(...ctx.remainingAccounts);\n      }\n\n      if (ctx.__private && ctx.__private.logAccounts) {\n        console.log(\"Outgoing account metas:\", keys);\n      }\n\n      return new TransactionInstruction({\n        keys,\n        programId,\n        data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs))\n      });\n    }; // Utility fn for ordering the accounts for this instruction.\n\n\n    ix[\"accounts\"] = accs => {\n      return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts);\n    };\n\n    return ix;\n  }\n\n  static accountsArray(ctx, accounts) {\n    return accounts.map(acc => {\n      // Nested accounts.\n      // @ts-ignore\n      const nestedAccounts = acc.accounts;\n\n      if (nestedAccounts !== undefined) {\n        const rpcAccs = ctx[acc.name];\n        return InstructionNamespaceFactory.accountsArray(rpcAccs, nestedAccounts).flat();\n      } else {\n        const account = acc;\n        return {\n          pubkey: translateAddress(ctx[acc.name]),\n          isWritable: account.isMut,\n          isSigner: account.isSigner\n        };\n      }\n    }).flat();\n  }\n\n} // Throws error if any argument required for the `ix` is not given.\n\nfunction validateInstruction(ix, ...args) {// todo\n}","map":{"version":3,"sources":["../../../../src/program/namespace/instruction.ts"],"names":[],"mappings":"AAAA,SAAoB,sBAApB,QAAkD,iBAAlD;AAEA,SAAS,QAAT,QAAyB,aAAzB;AACA,SACE,aADF,EAEE,gBAFF,EAGE,gBAHF,QAKO,WALP;AAMA,SAAmB,eAAnB,QAA0C,YAA1C;AAEA,eAAc,MAAO,2BAAP,CAAkC;AAC3B,SAAL,KAAK,CACjB,KADiB,EAEjB,QAFiB,EAGjB,SAHiB,EAGG;AAEpB,QAAI,KAAK,CAAC,IAAN,KAAe,QAAnB,EAA6B;AAC3B,YAAM,IAAI,QAAJ,CAAa,6BAAb,CAAN;AACD;;AAED,UAAM,EAAE,GAAG,CAAC,GAAG,IAAJ,KAA2C;AACpD,YAAM,CAAC,MAAD,EAAS,GAAT,IAAgB,eAAe,CAAC,KAAD,EAAQ,CAAC,GAAG,IAAJ,CAAR,CAArC;AACA,MAAA,gBAAgB,CAAC,KAAK,CAAC,QAAP,EAAiB,GAAG,CAAC,QAArB,CAAhB;AACA,MAAA,mBAAmB,CAAC,KAAD,EAAQ,GAAG,IAAX,CAAnB;AAEA,YAAM,IAAI,GAAG,EAAE,CAAC,QAAH,CAAY,GAAG,CAAC,QAAhB,CAAb;;AAEA,UAAI,GAAG,CAAC,iBAAJ,KAA0B,SAA9B,EAAyC;AACvC,QAAA,IAAI,CAAC,IAAL,CAAU,GAAG,GAAG,CAAC,iBAAjB;AACD;;AAED,UAAI,GAAG,CAAC,SAAJ,IAAiB,GAAG,CAAC,SAAJ,CAAc,WAAnC,EAAgD;AAC9C,QAAA,OAAO,CAAC,GAAR,CAAY,yBAAZ,EAAuC,IAAvC;AACD;;AACD,aAAO,IAAI,sBAAJ,CAA2B;AAChC,QAAA,IADgC;AAEhC,QAAA,SAFgC;AAGhC,QAAA,IAAI,EAAE,QAAQ,CAAC,KAAK,CAAC,IAAP,EAAa,aAAa,CAAC,KAAD,EAAQ,GAAG,MAAX,CAA1B;AAHkB,OAA3B,CAAP;AAKD,KAnBD,CANoB,CA2BpB;;;AACA,IAAA,EAAE,CAAC,UAAD,CAAF,GAAkB,IAAD,IAAmB;AAClC,aAAO,2BAA2B,CAAC,aAA5B,CAA0C,IAA1C,EAAgD,KAAK,CAAC,QAAtD,CAAP;AACD,KAFD;;AAIA,WAAO,EAAP;AACD;;AAE0B,SAAb,aAAa,CAAC,GAAD,EAAgB,QAAhB,EAA0C;AACnE,WAAO,QAAQ,CACZ,GADI,CACC,GAAD,IAAwB;AAC3B;AACA;AACA,YAAM,cAAc,GAAiC,GAAG,CAAC,QAAzD;;AACA,UAAI,cAAc,KAAK,SAAvB,EAAkC;AAChC,cAAM,OAAO,GAAG,GAAG,CAAC,GAAG,CAAC,IAAL,CAAnB;AACA,eAAO,2BAA2B,CAAC,aAA5B,CACL,OADK,EAEL,cAFK,EAGL,IAHK,EAAP;AAID,OAND,MAMO;AACL,cAAM,OAAO,GAAe,GAA5B;AACA,eAAO;AACL,UAAA,MAAM,EAAE,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,IAAL,CAAJ,CADnB;AAEL,UAAA,UAAU,EAAE,OAAO,CAAC,KAFf;AAGL,UAAA,QAAQ,EAAE,OAAO,CAAC;AAHb,SAAP;AAKD;AACF,KAnBI,EAoBJ,IApBI,EAAP;AAqBD;;AA7D6C,C,CA6GhD;;AACA,SAAS,mBAAT,CAA6B,EAA7B,EAAiD,GAAG,IAApD,EAA+D,CAC7D;AACD","sourceRoot":"","sourcesContent":["import { TransactionInstruction } from \"@solana/web3.js\";\r\nimport { IdlError } from \"../../error\";\r\nimport { toInstruction, validateAccounts, translateAddress, } from \"../common\";\r\nimport { splitArgsAndCtx } from \"../context\";\r\nexport default class InstructionNamespaceFactory {\r\n    static build(idlIx, encodeFn, programId) {\r\n        if (idlIx.name === \"_inner\") {\r\n            throw new IdlError(\"the _inner name is reserved\");\r\n        }\r\n        const ix = (...args) => {\r\n            const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\r\n            validateAccounts(idlIx.accounts, ctx.accounts);\r\n            validateInstruction(idlIx, ...args);\r\n            const keys = ix.accounts(ctx.accounts);\r\n            if (ctx.remainingAccounts !== undefined) {\r\n                keys.push(...ctx.remainingAccounts);\r\n            }\r\n            if (ctx.__private && ctx.__private.logAccounts) {\r\n                console.log(\"Outgoing account metas:\", keys);\r\n            }\r\n            return new TransactionInstruction({\r\n                keys,\r\n                programId,\r\n                data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs)),\r\n            });\r\n        };\r\n        // Utility fn for ordering the accounts for this instruction.\r\n        ix[\"accounts\"] = (accs) => {\r\n            return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts);\r\n        };\r\n        return ix;\r\n    }\r\n    static accountsArray(ctx, accounts) {\r\n        return accounts\r\n            .map((acc) => {\r\n            // Nested accounts.\r\n            // @ts-ignore\r\n            const nestedAccounts = acc.accounts;\r\n            if (nestedAccounts !== undefined) {\r\n                const rpcAccs = ctx[acc.name];\r\n                return InstructionNamespaceFactory.accountsArray(rpcAccs, nestedAccounts).flat();\r\n            }\r\n            else {\r\n                const account = acc;\r\n                return {\r\n                    pubkey: translateAddress(ctx[acc.name]),\r\n                    isWritable: account.isMut,\r\n                    isSigner: account.isSigner,\r\n                };\r\n            }\r\n        })\r\n            .flat();\r\n    }\r\n}\r\n// Throws error if any argument required for the `ix` is not given.\r\nfunction validateInstruction(ix, ...args) {\r\n    // todo\r\n}\r\n//# sourceMappingURL=instruction.js.map"]},"metadata":{},"sourceType":"module"}