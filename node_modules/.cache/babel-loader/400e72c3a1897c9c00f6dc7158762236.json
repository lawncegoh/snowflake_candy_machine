{"ast":null,"code":"import { Connection, Keypair, sendAndConfirmRawTransaction } from \"@solana/web3.js\";\nimport { isBrowser } from \"./utils/common\";\n/**\r\n * The network and wallet context used to send transactions paid for and signed\r\n * by the provider.\r\n */\n\nexport default class Provider {\n  /**\r\n   * @param connection The cluster connection where the program is deployed.\r\n   * @param wallet     The wallet used to pay for and sign all transactions.\r\n   * @param opts       Transaction confirmation options to use by default.\r\n   */\n  constructor(connection, wallet, opts) {\n    this.connection = connection;\n    this.wallet = wallet;\n    this.opts = opts;\n  }\n\n  static defaultOptions() {\n    return {\n      preflightCommitment: \"recent\",\n      commitment: \"recent\"\n    };\n  }\n  /**\r\n   * Returns a `Provider` with a wallet read from the local filesystem.\r\n   *\r\n   * @param url  The network cluster url.\r\n   * @param opts The default transaction confirmation options.\r\n   *\r\n   * (This api is for Node only.)\r\n   */\n\n\n  static local(url, opts) {\n    opts = opts !== null && opts !== void 0 ? opts : Provider.defaultOptions();\n    const connection = new Connection(url !== null && url !== void 0 ? url : \"http://localhost:8899\", opts.preflightCommitment);\n    const wallet = NodeWallet.local();\n    return new Provider(connection, wallet, opts);\n  }\n  /**\r\n   * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\r\n   * variable\r\n   *\r\n   * (This api is for Node only.)\r\n   */\n\n\n  static env() {\n    if (isBrowser) return;\n\n    const process = require(\"process\");\n\n    const url = process.env.ANCHOR_PROVIDER_URL;\n\n    if (url === undefined) {\n      throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\n    }\n\n    const options = Provider.defaultOptions();\n    const connection = new Connection(url, options.commitment);\n    const wallet = NodeWallet.local();\n    return new Provider(connection, wallet, options);\n  }\n  /**\r\n   * Sends the given transaction, paid for and signed by the provider's wallet.\r\n   *\r\n   * @param tx      The transaction to send.\r\n   * @param signers The set of signers in addition to the provdier wallet that\r\n   *                will sign the transaction.\r\n   * @param opts    Transaction confirmation options.\r\n   */\n\n\n  async send(tx, signers, opts) {\n    if (signers === undefined) {\n      signers = [];\n    }\n\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n\n    tx.feePayer = this.wallet.publicKey;\n    tx.recentBlockhash = (await this.connection.getRecentBlockhash(opts.preflightCommitment)).blockhash;\n    await this.wallet.signTransaction(tx);\n    signers.filter(s => s !== undefined).forEach(kp => {\n      tx.partialSign(kp);\n    });\n    const rawTx = tx.serialize();\n    const txId = await sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n    return txId;\n  }\n  /**\r\n   * Similar to `send`, but for an array of transactions and signers.\r\n   */\n\n\n  async sendAll(reqs, opts) {\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n\n    const blockhash = await this.connection.getRecentBlockhash(opts.preflightCommitment);\n    let txs = reqs.map(r => {\n      let tx = r.tx;\n      let signers = r.signers;\n\n      if (signers === undefined) {\n        signers = [];\n      }\n\n      tx.feePayer = this.wallet.publicKey;\n      tx.recentBlockhash = blockhash.blockhash;\n      signers.filter(s => s !== undefined).forEach(kp => {\n        tx.partialSign(kp);\n      });\n      return tx;\n    });\n    const signedTxs = await this.wallet.signAllTransactions(txs);\n    const sigs = [];\n\n    for (let k = 0; k < txs.length; k += 1) {\n      const tx = signedTxs[k];\n      const rawTx = tx.serialize();\n      sigs.push(await sendAndConfirmRawTransaction(this.connection, rawTx, opts));\n    }\n\n    return sigs;\n  }\n  /**\r\n   * Simulates the given transaction, returning emitted logs from execution.\r\n   *\r\n   * @param tx      The transaction to send.\r\n   * @param signers The set of signers in addition to the provdier wallet that\r\n   *                will sign the transaction.\r\n   * @param opts    Transaction confirmation options.\r\n   */\n\n\n  async simulate(tx, signers, opts) {\n    var _a, _b;\n\n    if (signers === undefined) {\n      signers = [];\n    }\n\n    if (opts === undefined) {\n      opts = this.opts;\n    }\n\n    tx.feePayer = this.wallet.publicKey;\n    tx.recentBlockhash = (await this.connection.getRecentBlockhash((_a = opts.preflightCommitment) !== null && _a !== void 0 ? _a : this.opts.preflightCommitment)).blockhash;\n    await this.wallet.signTransaction(tx);\n    signers.filter(s => s !== undefined).forEach(kp => {\n      tx.partialSign(kp);\n    });\n    return await simulateTransaction(this.connection, tx, (_b = opts.commitment) !== null && _b !== void 0 ? _b : this.opts.commitment);\n  }\n\n}\n/**\r\n * Node only wallet.\r\n */\n\nexport class NodeWallet {\n  constructor(payer) {\n    this.payer = payer;\n  }\n\n  static local() {\n    const payer = Keypair.fromSecretKey(Buffer.from(JSON.parse(require(\"fs\").readFileSync(require(\"os\").homedir() + \"/.config/solana/id.json\", {\n      encoding: \"utf-8\"\n    }))));\n    return new NodeWallet(payer);\n  }\n\n  async signTransaction(tx) {\n    tx.partialSign(this.payer);\n    return tx;\n  }\n\n  async signAllTransactions(txs) {\n    return txs.map(t => {\n      t.partialSign(this.payer);\n      return t;\n    });\n  }\n\n  get publicKey() {\n    return this.payer.publicKey;\n  }\n\n} // Copy of Connection.simulateTransaction that takes a commitment parameter.\n\nasync function simulateTransaction(connection, transaction, commitment) {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash( // @ts-ignore\n  connection._disableBlockhashCaching);\n  const signData = transaction.serializeMessage(); // @ts-ignore\n\n  const wireTransaction = transaction._serialize(signData);\n\n  const encodedTransaction = wireTransaction.toString(\"base64\");\n  const config = {\n    encoding: \"base64\",\n    commitment\n  };\n  const args = [encodedTransaction, config]; // @ts-ignore\n\n  const res = await connection._rpcRequest(\"simulateTransaction\", args);\n\n  if (res.error) {\n    throw new Error(\"failed to simulate transaction: \" + res.error.message);\n  }\n\n  return res.result;\n}\n/**\r\n * Sets the default provider on the client.\r\n */\n\n\nexport function setProvider(provider) {\n  _provider = provider;\n}\n/**\r\n * Returns the default provider being used by the client.\r\n */\n\nexport function getProvider() {\n  if (_provider === null) {\n    return Provider.local();\n  }\n\n  return _provider;\n} // Global provider used as the default when a provider is not given.\n\nlet _provider = null;","map":{"version":3,"sources":["../../src/provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Connection, Keypair, sendAndConfirmRawTransaction, } from \"@solana/web3.js\";\r\nimport { isBrowser } from \"./utils/common\";\r\n/**\r\n * The network and wallet context used to send transactions paid for and signed\r\n * by the provider.\r\n */\r\nexport default class Provider {\r\n    /**\r\n     * @param connection The cluster connection where the program is deployed.\r\n     * @param wallet     The wallet used to pay for and sign all transactions.\r\n     * @param opts       Transaction confirmation options to use by default.\r\n     */\r\n    constructor(connection, wallet, opts) {\r\n        this.connection = connection;\r\n        this.wallet = wallet;\r\n        this.opts = opts;\r\n    }\r\n    static defaultOptions() {\r\n        return {\r\n            preflightCommitment: \"recent\",\r\n            commitment: \"recent\",\r\n        };\r\n    }\r\n    /**\r\n     * Returns a `Provider` with a wallet read from the local filesystem.\r\n     *\r\n     * @param url  The network cluster url.\r\n     * @param opts The default transaction confirmation options.\r\n     *\r\n     * (This api is for Node only.)\r\n     */\r\n    static local(url, opts) {\r\n        opts = opts !== null && opts !== void 0 ? opts : Provider.defaultOptions();\r\n        const connection = new Connection(url !== null && url !== void 0 ? url : \"http://localhost:8899\", opts.preflightCommitment);\r\n        const wallet = NodeWallet.local();\r\n        return new Provider(connection, wallet, opts);\r\n    }\r\n    /**\r\n     * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\r\n     * variable\r\n     *\r\n     * (This api is for Node only.)\r\n     */\r\n    static env() {\r\n        if (isBrowser)\r\n            return;\r\n        const process = require(\"process\");\r\n        const url = process.env.ANCHOR_PROVIDER_URL;\r\n        if (url === undefined) {\r\n            throw new Error(\"ANCHOR_PROVIDER_URL is not defined\");\r\n        }\r\n        const options = Provider.defaultOptions();\r\n        const connection = new Connection(url, options.commitment);\r\n        const wallet = NodeWallet.local();\r\n        return new Provider(connection, wallet, options);\r\n    }\r\n    /**\r\n     * Sends the given transaction, paid for and signed by the provider's wallet.\r\n     *\r\n     * @param tx      The transaction to send.\r\n     * @param signers The set of signers in addition to the provdier wallet that\r\n     *                will sign the transaction.\r\n     * @param opts    Transaction confirmation options.\r\n     */\r\n    async send(tx, signers, opts) {\r\n        if (signers === undefined) {\r\n            signers = [];\r\n        }\r\n        if (opts === undefined) {\r\n            opts = this.opts;\r\n        }\r\n        tx.feePayer = this.wallet.publicKey;\r\n        tx.recentBlockhash = (await this.connection.getRecentBlockhash(opts.preflightCommitment)).blockhash;\r\n        await this.wallet.signTransaction(tx);\r\n        signers\r\n            .filter((s) => s !== undefined)\r\n            .forEach((kp) => {\r\n            tx.partialSign(kp);\r\n        });\r\n        const rawTx = tx.serialize();\r\n        const txId = await sendAndConfirmRawTransaction(this.connection, rawTx, opts);\r\n        return txId;\r\n    }\r\n    /**\r\n     * Similar to `send`, but for an array of transactions and signers.\r\n     */\r\n    async sendAll(reqs, opts) {\r\n        if (opts === undefined) {\r\n            opts = this.opts;\r\n        }\r\n        const blockhash = await this.connection.getRecentBlockhash(opts.preflightCommitment);\r\n        let txs = reqs.map((r) => {\r\n            let tx = r.tx;\r\n            let signers = r.signers;\r\n            if (signers === undefined) {\r\n                signers = [];\r\n            }\r\n            tx.feePayer = this.wallet.publicKey;\r\n            tx.recentBlockhash = blockhash.blockhash;\r\n            signers\r\n                .filter((s) => s !== undefined)\r\n                .forEach((kp) => {\r\n                tx.partialSign(kp);\r\n            });\r\n            return tx;\r\n        });\r\n        const signedTxs = await this.wallet.signAllTransactions(txs);\r\n        const sigs = [];\r\n        for (let k = 0; k < txs.length; k += 1) {\r\n            const tx = signedTxs[k];\r\n            const rawTx = tx.serialize();\r\n            sigs.push(await sendAndConfirmRawTransaction(this.connection, rawTx, opts));\r\n        }\r\n        return sigs;\r\n    }\r\n    /**\r\n     * Simulates the given transaction, returning emitted logs from execution.\r\n     *\r\n     * @param tx      The transaction to send.\r\n     * @param signers The set of signers in addition to the provdier wallet that\r\n     *                will sign the transaction.\r\n     * @param opts    Transaction confirmation options.\r\n     */\r\n    async simulate(tx, signers, opts) {\r\n        var _a, _b;\r\n        if (signers === undefined) {\r\n            signers = [];\r\n        }\r\n        if (opts === undefined) {\r\n            opts = this.opts;\r\n        }\r\n        tx.feePayer = this.wallet.publicKey;\r\n        tx.recentBlockhash = (await this.connection.getRecentBlockhash((_a = opts.preflightCommitment) !== null && _a !== void 0 ? _a : this.opts.preflightCommitment)).blockhash;\r\n        await this.wallet.signTransaction(tx);\r\n        signers\r\n            .filter((s) => s !== undefined)\r\n            .forEach((kp) => {\r\n            tx.partialSign(kp);\r\n        });\r\n        return await simulateTransaction(this.connection, tx, (_b = opts.commitment) !== null && _b !== void 0 ? _b : this.opts.commitment);\r\n    }\r\n}\r\n/**\r\n * Node only wallet.\r\n */\r\nexport class NodeWallet {\r\n    constructor(payer) {\r\n        this.payer = payer;\r\n    }\r\n    static local() {\r\n        const payer = Keypair.fromSecretKey(Buffer.from(JSON.parse(require(\"fs\").readFileSync(require(\"os\").homedir() + \"/.config/solana/id.json\", {\r\n            encoding: \"utf-8\",\r\n        }))));\r\n        return new NodeWallet(payer);\r\n    }\r\n    async signTransaction(tx) {\r\n        tx.partialSign(this.payer);\r\n        return tx;\r\n    }\r\n    async signAllTransactions(txs) {\r\n        return txs.map((t) => {\r\n            t.partialSign(this.payer);\r\n            return t;\r\n        });\r\n    }\r\n    get publicKey() {\r\n        return this.payer.publicKey;\r\n    }\r\n}\r\n// Copy of Connection.simulateTransaction that takes a commitment parameter.\r\nasync function simulateTransaction(connection, transaction, commitment) {\r\n    // @ts-ignore\r\n    transaction.recentBlockhash = await connection._recentBlockhash(\r\n    // @ts-ignore\r\n    connection._disableBlockhashCaching);\r\n    const signData = transaction.serializeMessage();\r\n    // @ts-ignore\r\n    const wireTransaction = transaction._serialize(signData);\r\n    const encodedTransaction = wireTransaction.toString(\"base64\");\r\n    const config = { encoding: \"base64\", commitment };\r\n    const args = [encodedTransaction, config];\r\n    // @ts-ignore\r\n    const res = await connection._rpcRequest(\"simulateTransaction\", args);\r\n    if (res.error) {\r\n        throw new Error(\"failed to simulate transaction: \" + res.error.message);\r\n    }\r\n    return res.result;\r\n}\r\n/**\r\n * Sets the default provider on the client.\r\n */\r\nexport function setProvider(provider) {\r\n    _provider = provider;\r\n}\r\n/**\r\n * Returns the default provider being used by the client.\r\n */\r\nexport function getProvider() {\r\n    if (_provider === null) {\r\n        return Provider.local();\r\n    }\r\n    return _provider;\r\n}\r\n// Global provider used as the default when a provider is not given.\r\nlet _provider = null;\r\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}