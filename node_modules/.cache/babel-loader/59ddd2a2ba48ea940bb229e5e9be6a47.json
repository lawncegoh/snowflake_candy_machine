{"ast":null,"code":"\"use strict\";\n\nfunction compile(nodes) {\n  var assignedPaths = [];\n  var valueAssignments = [];\n  var currentPath = \"\";\n  var data = Object.create(null);\n  var context = data;\n  var arrayMode = false;\n  return reduce(nodes);\n\n  function reduce(nodes) {\n    var node;\n\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n\n      switch (node.type) {\n        case \"Assign\":\n          assign(node);\n          break;\n\n        case \"ObjectPath\":\n          setPath(node);\n          break;\n\n        case \"ArrayPath\":\n          addTableArray(node);\n          break;\n      }\n    }\n\n    return data;\n  }\n\n  function genError(err, line, col) {\n    var ex = new Error(err);\n    ex.line = line;\n    ex.column = col;\n    throw ex;\n  }\n\n  function assign(node) {\n    var key = node.key;\n    var value = node.value;\n    var line = node.line;\n    var column = node.column;\n    var fullPath;\n\n    if (currentPath) {\n      fullPath = currentPath + \".\" + key;\n    } else {\n      fullPath = key;\n    }\n\n    if (typeof context[key] !== \"undefined\") {\n      genError(\"Cannot redefine existing key '\" + fullPath + \"'.\", line, column);\n    }\n\n    context[key] = reduceValueNode(value);\n\n    if (!pathAssigned(fullPath)) {\n      assignedPaths.push(fullPath);\n      valueAssignments.push(fullPath);\n    }\n  }\n\n  function pathAssigned(path) {\n    return assignedPaths.indexOf(path) !== -1;\n  }\n\n  function reduceValueNode(node) {\n    if (node.type === \"Array\") {\n      return reduceArrayWithTypeChecking(node.value);\n    } else if (node.type === \"InlineTable\") {\n      return reduceInlineTableNode(node.value);\n    } else {\n      return node.value;\n    }\n  }\n\n  function reduceInlineTableNode(values) {\n    var obj = Object.create(null);\n\n    for (var i = 0; i < values.length; i++) {\n      var val = values[i];\n\n      if (val.value.type === \"InlineTable\") {\n        obj[val.key] = reduceInlineTableNode(val.value.value);\n      } else if (val.type === \"InlineTableValue\") {\n        obj[val.key] = reduceValueNode(val.value);\n      }\n    }\n\n    return obj;\n  }\n\n  function setPath(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n\n    if (pathAssigned(quotedPath)) {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, Object.create(null), line, column);\n    currentPath = path;\n  }\n\n  function addTableArray(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n\n    if (!pathAssigned(quotedPath)) {\n      assignedPaths.push(quotedPath);\n    }\n\n    assignedPaths = assignedPaths.filter(function (p) {\n      return p.indexOf(quotedPath) !== 0;\n    });\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, [], line, column);\n    currentPath = quotedPath;\n\n    if (context instanceof Array) {\n      var newObj = Object.create(null);\n      context.push(newObj);\n      context = newObj;\n    } else {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n  } // Given a path 'a.b.c', create (as necessary) `start.a`,\n  // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.\n  // If `a` or `b` are arrays and have items in them, the last item in the\n  // array is used as the context for the next sub-path.\n\n\n  function deepRef(start, keys, value, line, column) {\n    var traversed = [];\n    var traversedPath = \"\";\n    var path = keys.join(\".\");\n    var ctx = start;\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      traversed.push(key);\n      traversedPath = traversed.join(\".\");\n\n      if (typeof ctx[key] === \"undefined\") {\n        if (i === keys.length - 1) {\n          ctx[key] = value;\n        } else {\n          ctx[key] = Object.create(null);\n        }\n      } else if (i !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {\n        // already a non-object value at key, can't be used as part of a new path\n        genError(\"Cannot redefine existing key '\" + traversedPath + \"'.\", line, column);\n      }\n\n      ctx = ctx[key];\n\n      if (ctx instanceof Array && ctx.length && i < keys.length - 1) {\n        ctx = ctx[ctx.length - 1];\n      }\n    }\n\n    return ctx;\n  }\n\n  function reduceArrayWithTypeChecking(array) {\n    // Ensure that all items in the array are of the same type\n    var firstType = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var node = array[i];\n\n      if (firstType === null) {\n        firstType = node.type;\n      } else {\n        if (node.type !== firstType) {\n          genError(\"Cannot add value of type \" + node.type + \" to array of type \" + firstType + \".\", node.line, node.column);\n        }\n      }\n    } // Recursively reduce array of nodes into array of the nodes' values\n\n\n    return array.map(reduceValueNode);\n  }\n\n  function quoteDottedString(str) {\n    if (str.indexOf(\".\") > -1) {\n      return \"\\\"\" + str + \"\\\"\";\n    } else {\n      return str;\n    }\n  }\n}\n\nmodule.exports = {\n  compile: compile\n};","map":{"version":3,"sources":["C:/Users/User/OneDrive/Desktop/snowflake_candy_machine/node_modules/toml/lib/compiler.js"],"names":["compile","nodes","assignedPaths","valueAssignments","currentPath","data","Object","create","context","arrayMode","reduce","node","i","length","type","assign","setPath","addTableArray","genError","err","line","col","ex","Error","column","key","value","fullPath","reduceValueNode","pathAssigned","push","path","indexOf","reduceArrayWithTypeChecking","reduceInlineTableNode","values","obj","val","quotedPath","map","quoteDottedString","join","deepRef","filter","p","Array","newObj","start","keys","traversed","traversedPath","ctx","array","firstType","str","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\r\nfunction compile(nodes) {\r\n  var assignedPaths = [];\r\n  var valueAssignments = [];\r\n  var currentPath = \"\";\r\n  var data = Object.create(null);\r\n  var context = data;\r\n  var arrayMode = false;\r\n\r\n  return reduce(nodes);\r\n\r\n  function reduce(nodes) {\r\n    var node;\r\n    for (var i = 0; i < nodes.length; i++) {\r\n      node = nodes[i];\r\n      switch (node.type) {\r\n      case \"Assign\":\r\n        assign(node);\r\n        break;\r\n      case \"ObjectPath\":\r\n        setPath(node);\r\n        break;\r\n      case \"ArrayPath\":\r\n        addTableArray(node);\r\n        break;\r\n      }\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  function genError(err, line, col) {\r\n    var ex = new Error(err);\r\n    ex.line = line;\r\n    ex.column = col;\r\n    throw ex;\r\n  }\r\n\r\n  function assign(node) {\r\n    var key = node.key;\r\n    var value = node.value;\r\n    var line = node.line;\r\n    var column = node.column;\r\n\r\n    var fullPath;\r\n    if (currentPath) {\r\n      fullPath = currentPath + \".\" + key;\r\n    } else {\r\n      fullPath = key;\r\n    }\r\n    if (typeof context[key] !== \"undefined\") {\r\n      genError(\"Cannot redefine existing key '\" + fullPath + \"'.\", line, column);\r\n    }\r\n\r\n    context[key] = reduceValueNode(value);\r\n\r\n    if (!pathAssigned(fullPath)) {\r\n      assignedPaths.push(fullPath);\r\n      valueAssignments.push(fullPath);\r\n    }\r\n  }\r\n\r\n\r\n  function pathAssigned(path) {\r\n    return assignedPaths.indexOf(path) !== -1;\r\n  }\r\n\r\n  function reduceValueNode(node) {\r\n    if (node.type === \"Array\") {\r\n      return reduceArrayWithTypeChecking(node.value);\r\n    } else if (node.type === \"InlineTable\") {\r\n      return reduceInlineTableNode(node.value);\r\n    } else {\r\n      return node.value;\r\n    }\r\n  }\r\n\r\n  function reduceInlineTableNode(values) {\r\n    var obj = Object.create(null);\r\n    for (var i = 0; i < values.length; i++) {\r\n      var val = values[i];\r\n      if (val.value.type === \"InlineTable\") {\r\n        obj[val.key] = reduceInlineTableNode(val.value.value);\r\n      } else if (val.type === \"InlineTableValue\") {\r\n        obj[val.key] = reduceValueNode(val.value);\r\n      }\r\n    }\r\n\r\n    return obj;\r\n  }\r\n\r\n  function setPath(node) {\r\n    var path = node.value;\r\n    var quotedPath = path.map(quoteDottedString).join(\".\");\r\n    var line = node.line;\r\n    var column = node.column;\r\n\r\n    if (pathAssigned(quotedPath)) {\r\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\r\n    }\r\n    assignedPaths.push(quotedPath);\r\n    context = deepRef(data, path, Object.create(null), line, column);\r\n    currentPath = path;\r\n  }\r\n\r\n  function addTableArray(node) {\r\n    var path = node.value;\r\n    var quotedPath = path.map(quoteDottedString).join(\".\");\r\n    var line = node.line;\r\n    var column = node.column;\r\n\r\n    if (!pathAssigned(quotedPath)) {\r\n      assignedPaths.push(quotedPath);\r\n    }\r\n    assignedPaths = assignedPaths.filter(function(p) {\r\n      return p.indexOf(quotedPath) !== 0;\r\n    });\r\n    assignedPaths.push(quotedPath);\r\n    context = deepRef(data, path, [], line, column);\r\n    currentPath = quotedPath;\r\n\r\n    if (context instanceof Array) {\r\n      var newObj = Object.create(null);\r\n      context.push(newObj);\r\n      context = newObj;\r\n    } else {\r\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\r\n    }\r\n  }\r\n\r\n  // Given a path 'a.b.c', create (as necessary) `start.a`,\r\n  // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.\r\n  // If `a` or `b` are arrays and have items in them, the last item in the\r\n  // array is used as the context for the next sub-path.\r\n  function deepRef(start, keys, value, line, column) {\r\n    var traversed = [];\r\n    var traversedPath = \"\";\r\n    var path = keys.join(\".\");\r\n    var ctx = start;\r\n\r\n    for (var i = 0; i < keys.length; i++) {\r\n      var key = keys[i];\r\n      traversed.push(key);\r\n      traversedPath = traversed.join(\".\");\r\n      if (typeof ctx[key] === \"undefined\") {\r\n        if (i === keys.length - 1) {\r\n          ctx[key] = value;\r\n        } else {\r\n          ctx[key] = Object.create(null);\r\n        }\r\n      } else if (i !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {\r\n        // already a non-object value at key, can't be used as part of a new path\r\n        genError(\"Cannot redefine existing key '\" + traversedPath + \"'.\", line, column);\r\n      }\r\n\r\n      ctx = ctx[key];\r\n      if (ctx instanceof Array && ctx.length && i < keys.length - 1) {\r\n        ctx = ctx[ctx.length - 1];\r\n      }\r\n    }\r\n\r\n    return ctx;\r\n  }\r\n\r\n  function reduceArrayWithTypeChecking(array) {\r\n    // Ensure that all items in the array are of the same type\r\n    var firstType = null;\r\n    for (var i = 0; i < array.length; i++) {\r\n      var node = array[i];\r\n      if (firstType === null) {\r\n        firstType = node.type;\r\n      } else {\r\n        if (node.type !== firstType) {\r\n          genError(\"Cannot add value of type \" + node.type + \" to array of type \" +\r\n            firstType + \".\", node.line, node.column);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Recursively reduce array of nodes into array of the nodes' values\r\n    return array.map(reduceValueNode);\r\n  }\r\n\r\n  function quoteDottedString(str) {\r\n    if (str.indexOf(\".\") > -1) {\r\n      return \"\\\"\" + str + \"\\\"\";\r\n    } else {\r\n      return str;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  compile: compile\r\n};\r\n"]},"metadata":{},"sourceType":"script"}