{"ast":null,"code":"/* The MIT License (MIT)\r\n *\r\n * Copyright 2015-2018 Peter A. Bigot\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\n\n/**\r\n * Support for translating between Uint8Array instances and JavaScript\r\n * native types.\r\n *\r\n * {@link module:Layout~Layout|Layout} is the basis of a class\r\n * hierarchy that associates property names with sequences of encoded\r\n * bytes.\r\n *\r\n * Layouts are supported for these scalar (numeric) types:\r\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\r\n *   format} with {@link module:Layout.u8|8-bit}, {@link\r\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\r\n *   {@link module:Layout.u32|32-bit}, {@link\r\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\r\n *   representation ranges;\r\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\r\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\r\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\r\n *   {@link module:Layout.u40be|40-bit}, and {@link\r\n *   module:Layout.u48be|48-bit} representation ranges;\r\n * * {@link module:Layout~Int|Signed integers in little-endian\r\n *   format} with {@link module:Layout.s8|8-bit}, {@link\r\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\r\n *   {@link module:Layout.s32|32-bit}, {@link\r\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\r\n *   representation ranges;\r\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\r\n *   with {@link module:Layout.s16be|16-bit}, {@link\r\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\r\n *   {@link module:Layout.s40be|40-bit}, and {@link\r\n *   module:Layout.s48be|48-bit} representation ranges;\r\n * * 64-bit integral values that decode to an exact (if magnitude is\r\n *   less than 2^53) or nearby integral Number in {@link\r\n *   module:Layout.nu64|unsigned little-endian}, {@link\r\n *   module:Layout.nu64be|unsigned big-endian}, {@link\r\n *   module:Layout.ns64|signed little-endian}, and {@link\r\n *   module:Layout.ns64be|unsigned big-endian} encodings;\r\n * * 32-bit floating point values with {@link\r\n *   module:Layout.f32|little-endian} and {@link\r\n *   module:Layout.f32be|big-endian} representations;\r\n * * 64-bit floating point values with {@link\r\n *   module:Layout.f64|little-endian} and {@link\r\n *   module:Layout.f64be|big-endian} representations;\r\n * * {@link module:Layout.const|Constants} that take no space in the\r\n *   encoded expression.\r\n *\r\n * and for these aggregate types:\r\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\r\n *   module:Layout~Layout|Layout}, with JavaScript representation as\r\n *   an Array and constant or data-dependent {@link\r\n *   module:Layout~Sequence#count|length};\r\n * * {@link module:Layout.struct|Structure}s that aggregate a\r\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\r\n *   instances, with JavaScript representation as an Object;\r\n * * {@link module:Layout.union|Union}s that support multiple {@link\r\n *   module:Layout~VariantLayout|variant layouts} over a fixed\r\n *   (padded) or variable (not padded) span of bytes, using an\r\n *   unsigned integer at the start of the data or a separate {@link\r\n *   module:Layout.unionLayoutDiscriminator|layout element} to\r\n *   determine which layout to use when interpreting the buffer\r\n *   contents;\r\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\r\n *   of individual {@link\r\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\r\n *   16, 24, or 32-bit unsigned integer starting at the least- or\r\n *   most-significant bit;\r\n * * {@link module:Layout.cstr|C strings} of varying length;\r\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\r\n *   module:Layout~Blob#length|length} raw data.\r\n *\r\n * All {@link module:Layout~Layout|Layout} instances are immutable\r\n * after construction, to prevent internal state from becoming\r\n * inconsistent.\r\n *\r\n * @local Layout\r\n * @local ExternalLayout\r\n * @local GreedyCount\r\n * @local OffsetLayout\r\n * @local UInt\r\n * @local UIntBE\r\n * @local Int\r\n * @local IntBE\r\n * @local NearUInt64\r\n * @local NearUInt64BE\r\n * @local NearInt64\r\n * @local NearInt64BE\r\n * @local Float\r\n * @local FloatBE\r\n * @local Double\r\n * @local DoubleBE\r\n * @local Sequence\r\n * @local Structure\r\n * @local UnionDiscriminator\r\n * @local UnionLayoutDiscriminator\r\n * @local Union\r\n * @local VariantLayout\r\n * @local BitStructure\r\n * @local BitField\r\n * @local Boolean\r\n * @local Blob\r\n * @local CString\r\n * @local Constant\r\n * @local bindConstructorLayout\r\n * @module Layout\r\n * @license MIT\r\n * @author Peter A. Bigot\r\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\r\n */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nexports.__esModule = true;\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\n\nvar buffer_1 = require(\"buffer\");\n/* Check if a value is a Uint8Array.\r\n *\r\n * @ignore */\n\n\nfunction checkUint8Array(b) {\n  if (!(b instanceof Uint8Array)) {\n    throw new TypeError('b must be a Uint8Array');\n  }\n}\n\nexports.checkUint8Array = checkUint8Array;\n/* Create a Buffer instance from a Uint8Array.\r\n *\r\n * @ignore */\n\nfunction uint8ArrayToBuffer(b) {\n  checkUint8Array(b);\n  return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n}\n\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\n/**\r\n * Base class for layout objects.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support the {@link\r\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\r\n *\r\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\r\n * parameter must be an integer; a negative value signifies that the\r\n * span is {@link Layout#getSpan|value-specific}.\r\n *\r\n * @param {string} [property] - Initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @abstract\r\n */\n\nvar Layout =\n/** @class */\nfunction () {\n  function Layout(span, property) {\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n    /** The span of the layout in bytes.\r\n     *\r\n     * Positive values are generally expected.\r\n     *\r\n     * Zero will only appear in {@link Constant}s and in {@link\r\n     * Sequence}s where the {@link Sequence#count|count} is zero.\r\n     *\r\n     * A negative value indicates that the span is value-specific, and\r\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n\n\n    this.span = span;\n    /** The property name used when this layout is represented in an\r\n     * Object.\r\n     *\r\n     * Used only for layouts that {@link Layout#decode|decode} to Object\r\n     * instances.  If left undefined the span of the unnamed layout will\r\n     * be treated as padding: it will not be mutated by {@link\r\n     * Layout#encode|encode} nor represented as a property in the\r\n     * decoded Object. */\n\n    this.property = property;\n  }\n  /** Function to create an Object into which decoded properties will\r\n   * be written.\r\n   *\r\n   * Used only for layouts that {@link Layout#decode|decode} to Object\r\n   * instances, which means:\r\n   * * {@link Structure}\r\n   * * {@link Union}\r\n   * * {@link VariantLayout}\r\n   * * {@link BitStructure}\r\n   *\r\n   * If left undefined the JavaScript representation of these layouts\r\n   * will be Object instances.\r\n   *\r\n   * See {@link bindConstructorLayout}.\r\n   */\n\n\n  Layout.prototype.makeDestinationObject = function () {\n    return {};\n  };\n  /**\r\n   * Decode from a Uint8Array into a JavaScript value.\r\n   *\r\n   * @param {Uint8Array} b - the buffer from which encoded data is read.\r\n   *\r\n   * @param {Number} [offset] - the offset at which the encoded data\r\n   * starts.  If absent a zero offset is inferred.\r\n   *\r\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\r\n   *\r\n   * @abstract\r\n   */\n\n\n  Layout.prototype.decode = function (b, offset) {\n    throw new Error('Layout is abstract');\n  };\n  /**\r\n   * Encode a JavaScript value into a Uint8Array.\r\n   *\r\n   * @param {(Number|Array|Object)} src - the value to be encoded into\r\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\r\n   * Layout}.\r\n   *\r\n   * @param {Uint8Array} b - the buffer into which encoded data will be\r\n   * written.\r\n   *\r\n   * @param {Number} [offset] - the offset at which the encoded data\r\n   * starts.  If absent a zero offset is inferred.\r\n   *\r\n   * @returns {Number} - the number of bytes encoded, including the\r\n   * space skipped for internal padding, but excluding data such as\r\n   * {@link Sequence#count|lengths} when stored {@link\r\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\r\n   * producing the offset where data for the next layout would be\r\n   * written.\r\n   *\r\n   * @abstract\r\n   */\n\n\n  Layout.prototype.encode = function (src, b, offset) {\n    throw new Error('Layout is abstract');\n  };\n  /**\r\n   * Calculate the span of a specific instance of a layout.\r\n   *\r\n   * @param {Uint8Array} b - the buffer that contains an encoded instance.\r\n   *\r\n   * @param {Number} [offset] - the offset at which the encoded instance\r\n   * starts.  If absent a zero offset is inferred.\r\n   *\r\n   * @return {Number} - the number of bytes covered by the layout\r\n   * instance.  If this method is not overridden in a subclass the\r\n   * definition-time constant {@link Layout#span|span} will be\r\n   * returned.\r\n   *\r\n   * @throws {RangeError} - if the length of the value cannot be\r\n   * determined.\r\n   */\n\n\n  Layout.prototype.getSpan = function (b, offset) {\n    if (0 > this.span) {\n      throw new RangeError('indeterminate span');\n    }\n\n    return this.span;\n  };\n  /**\r\n   * Replicate the layout using a new property.\r\n   *\r\n   * This function must be used to get a structurally-equivalent layout\r\n   * with a different name since all {@link Layout} instances are\r\n   * immutable.\r\n   *\r\n   * **NOTE** This is a shallow copy.  All fields except {@link\r\n   * Layout#property|property} are strictly equal to the origin layout.\r\n   *\r\n   * @param {String} property - the value for {@link\r\n   * Layout#property|property} in the replica.\r\n   *\r\n   * @returns {Layout} - the copy with {@link Layout#property|property}\r\n   * set to `property`.\r\n   */\n\n\n  Layout.prototype.replicate = function (property) {\n    var rv = Object.create(this.constructor.prototype);\n    Object.assign(rv, this);\n    rv.property = property;\n    return rv;\n  };\n  /**\r\n   * Create an object from layout properties and an array of values.\r\n   *\r\n   * **NOTE** This function returns `undefined` if invoked on a layout\r\n   * that does not return its value as an Object.  Objects are\r\n   * returned for things that are a {@link Structure}, which includes\r\n   * {@link VariantLayout|variant layouts} if they are structures, and\r\n   * excludes {@link Union}s.  If you want this feature for a union\r\n   * you must use {@link Union.getVariant|getVariant} to select the\r\n   * desired layout.\r\n   *\r\n   * @param {Array} values - an array of values that correspond to the\r\n   * default order for properties.  As with {@link Layout#decode|decode}\r\n   * layout elements that have no property name are skipped when\r\n   * iterating over the array values.  Only the top-level properties are\r\n   * assigned; arguments are not assigned to properties of contained\r\n   * layouts.  Any unused values are ignored.\r\n   *\r\n   * @return {(Object|undefined)}\r\n   */\n\n\n  Layout.prototype.fromArray = function (values) {\n    return undefined;\n  };\n\n  return Layout;\n}();\n\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\r\n * be throwing an error) annotated with the property of a given layout\r\n * (such as one for which the value was unacceptable).\r\n *\r\n * @ignore */\n\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n\n  return name;\n}\n\nexports.nameWithProperty = nameWithProperty;\n/**\r\n * Augment a class so that instances can be encoded/decoded using a\r\n * given layout.\r\n *\r\n * Calling this function couples `Class` with `layout` in several ways:\r\n *\r\n * * `Class.layout_` becomes a static member property equal to `layout`;\r\n * * `layout.boundConstructor_` becomes a static member property equal\r\n *    to `Class`;\r\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\r\n *   property of `layout` is set to a function that returns a `new\r\n *   Class()`;\r\n * * `Class.decode(b, offset)` becomes a static member function that\r\n *   delegates to {@link Layout#decode|layout.decode}.  The\r\n *   synthesized function may be captured and extended.\r\n * * `Class.prototype.encode(b, offset)` provides an instance member\r\n *   function that delegates to {@link Layout#encode|layout.encode}\r\n *   with `src` set to `this`.  The synthesized function may be\r\n *   captured and extended, but when the extension is invoked `this`\r\n *   must be explicitly bound to the instance.\r\n *\r\n * @param {class} Class - a JavaScript class with a nullary\r\n * constructor.\r\n *\r\n * @param {Layout} layout - the {@link Layout} instance used to encode\r\n * instances of `Class`.\r\n */\n\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n\n  if (Object.prototype.hasOwnProperty.call(Class, 'layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n\n  if (!(layout && layout instanceof Layout)) {\n    throw new TypeError('layout must be a Layout');\n  }\n\n  if (Object.prototype.hasOwnProperty.call(layout, 'boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n\n  layout.makeDestinationObject = function () {\n    return new Class();\n  };\n\n  Object.defineProperty(Class.prototype, 'encode', {\n    value: function (b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true\n  });\n  Object.defineProperty(Class, 'decode', {\n    value: function (b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true\n  });\n}\n\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\r\n * An object that behaves like a layout but does not consume space\r\n * within its containing layout.\r\n *\r\n * This is primarily used to obtain metadata about a member, such as a\r\n * {@link OffsetLayout} that can provide data about a {@link\r\n * Layout#getSpan|value-specific span}.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support {@link\r\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @abstract\r\n * @augments {Layout}\r\n */\n\nvar ExternalLayout =\n/** @class */\nfunction (_super) {\n  __extends(ExternalLayout, _super);\n\n  function ExternalLayout() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Return `true` iff the external layout decodes to an unsigned\r\n   * integer layout.\r\n   *\r\n   * In that case it can be used as the source of {@link\r\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\r\n   * or as {@link UnionLayoutDiscriminator#layout|external union\r\n   * discriminators}.\r\n   *\r\n   * @abstract\r\n   */\n\n\n  ExternalLayout.prototype.isCount = function () {\n    throw new Error('ExternalLayout is abstract');\n  };\n\n  return ExternalLayout;\n}(Layout);\n\nexports.ExternalLayout = ExternalLayout;\n/**\r\n * An {@link ExternalLayout} that determines its {@link\r\n * Layout#decode|value} based on offset into and length of the buffer\r\n * on which it is invoked.\r\n *\r\n * *Factory*: {@link module:Layout.greedy|greedy}\r\n *\r\n * @param {Number} [elementSpan] - initializer for {@link\r\n * GreedyCount#elementSpan|elementSpan}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {ExternalLayout}\r\n */\n\nvar GreedyCount =\n/** @class */\nfunction (_super) {\n  __extends(GreedyCount, _super);\n\n  function GreedyCount(elementSpan, property) {\n    var _this = this;\n\n    if (undefined === elementSpan) {\n      elementSpan = 1;\n    }\n\n    if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n\n    _this = _super.call(this, -1, property) || this;\n    /** The layout for individual elements of the sequence.  The value\r\n     * must be a positive integer.  If not provided, the value will be\r\n     * 1. */\n\n    _this.elementSpan = elementSpan;\n    return _this;\n  }\n  /** @override */\n\n\n  GreedyCount.prototype.isCount = function () {\n    return true;\n  };\n  /** @override */\n\n\n  GreedyCount.prototype.decode = function (b, offset) {\n    checkUint8Array(b);\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var rem = b.length - offset;\n    return Math.floor(rem / this.elementSpan);\n  };\n  /** @override */\n\n\n  GreedyCount.prototype.encode = function (src, b, offset) {\n    return 0;\n  };\n\n  return GreedyCount;\n}(ExternalLayout);\n\nexports.GreedyCount = GreedyCount;\n/**\r\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\r\n * at a fixed offset from the start of another Layout.  The offset may\r\n * be before, within, or after the base layout.\r\n *\r\n * *Factory*: {@link module:Layout.offset|offset}\r\n *\r\n * @param {Layout} layout - initializer for {@link\r\n * OffsetLayout#layout|layout}, modulo `property`.\r\n *\r\n * @param {Number} [offset] - Initializes {@link\r\n * OffsetLayout#offset|offset}.  Defaults to zero.\r\n *\r\n * @param {string} [property] - Optional new property name for a\r\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\r\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\r\n * unchanged.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar OffsetLayout =\n/** @class */\nfunction (_super) {\n  __extends(OffsetLayout, _super);\n\n  function OffsetLayout(layout, offset, property) {\n    var _this = this;\n\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n\n    _this = _super.call(this, layout.span, property || layout.property) || this;\n    /** The subordinated layout. */\n\n    _this.layout = layout;\n    /** The location of {@link OffsetLayout#layout} relative to the\r\n     * start of another layout.\r\n     *\r\n     * The value may be positive or negative, but an error will thrown\r\n     * if at the point of use it goes outside the span of the Uint8Array\r\n     * being accessed.  */\n\n    _this.offset = offset;\n    return _this;\n  }\n  /** @override */\n\n\n  OffsetLayout.prototype.isCount = function () {\n    return this.layout instanceof UInt || this.layout instanceof UIntBE;\n  };\n  /** @override */\n\n\n  OffsetLayout.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return this.layout.decode(b, offset + this.offset);\n  };\n  /** @override */\n\n\n  OffsetLayout.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return this.layout.encode(src, b, offset + this.offset);\n  };\n\n  return OffsetLayout;\n}(ExternalLayout);\n\nexports.OffsetLayout = OffsetLayout;\n/**\r\n * Represent an unsigned integer in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.u8|u8}, {@link\r\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\r\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\r\n *  module:Layout.u48|u48}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar UInt =\n/** @class */\nfunction (_super) {\n  __extends(UInt, _super);\n\n  function UInt(span, property) {\n    var _this = _super.call(this, span, property) || this;\n\n    if (6 < _this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n\n    return _this;\n  }\n  /** @override */\n\n\n  UInt.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\n  };\n  /** @override */\n\n\n  UInt.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\n    return this.span;\n  };\n\n  return UInt;\n}(Layout);\n\nexports.UInt = UInt;\n/**\r\n * Represent an unsigned integer in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\r\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\r\n * {@link module:Layout.u32be|u32be}, {@link\r\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar UIntBE =\n/** @class */\nfunction (_super) {\n  __extends(UIntBE, _super);\n\n  function UIntBE(span, property) {\n    var _this = _super.call(this, span, property) || this;\n\n    if (6 < _this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n\n    return _this;\n  }\n  /** @override */\n\n\n  UIntBE.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\n  };\n  /** @override */\n\n\n  UIntBE.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\n    return this.span;\n  };\n\n  return UIntBE;\n}(Layout);\n\nexports.UIntBE = UIntBE;\n/**\r\n * Represent a signed integer in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.s8|s8}, {@link\r\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\r\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\r\n *  module:Layout.s48|s48}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar Int =\n/** @class */\nfunction (_super) {\n  __extends(Int, _super);\n\n  function Int(span, property) {\n    var _this = _super.call(this, span, property) || this;\n\n    if (6 < _this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n\n    return _this;\n  }\n  /** @override */\n\n\n  Int.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\n  };\n  /** @override */\n\n\n  Int.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\n    return this.span;\n  };\n\n  return Int;\n}(Layout);\n\nexports.Int = Int;\n/**\r\n * Represent a signed integer in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\r\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\r\n * {@link module:Layout.s32be|s32be}, {@link\r\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar IntBE =\n/** @class */\nfunction (_super) {\n  __extends(IntBE, _super);\n\n  function IntBE(span, property) {\n    var _this = _super.call(this, span, property) || this;\n\n    if (6 < _this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n\n    return _this;\n  }\n  /** @override */\n\n\n  IntBE.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\n  };\n  /** @override */\n\n\n  IntBE.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\n    return this.span;\n  };\n\n  return IntBE;\n}(Layout);\n\nexports.IntBE = IntBE;\nvar V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\r\n * non-negative. */\n\nfunction divmodInt64(src) {\n  var hi32 = Math.floor(src / V2E32);\n  var lo32 = src - hi32 * V2E32;\n  return {\n    hi32: hi32,\n    lo32: lo32\n  };\n}\n/* Reconstruct Number from quotient and non-negative remainder */\n\n\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n/**\r\n * Represent an unsigned 64-bit integer in little-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.nu64|nu64}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar NearUInt64 =\n/** @class */\nfunction (_super) {\n  __extends(NearUInt64, _super);\n\n  function NearUInt64(property) {\n    return _super.call(this, 8, property) || this;\n  }\n  /** @override */\n\n\n  NearUInt64.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var buffer = uint8ArrayToBuffer(b);\n    var lo32 = buffer.readUInt32LE(offset);\n    var hi32 = buffer.readUInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  };\n  /** @override */\n\n\n  NearUInt64.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var split = divmodInt64(src);\n    var buffer = uint8ArrayToBuffer(b);\n    buffer.writeUInt32LE(split.lo32, offset);\n    buffer.writeUInt32LE(split.hi32, offset + 4);\n    return 8;\n  };\n\n  return NearUInt64;\n}(Layout);\n\nexports.NearUInt64 = NearUInt64;\n/**\r\n * Represent an unsigned 64-bit integer in big-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.nu64be|nu64be}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar NearUInt64BE =\n/** @class */\nfunction (_super) {\n  __extends(NearUInt64BE, _super);\n\n  function NearUInt64BE(property) {\n    return _super.call(this, 8, property) || this;\n  }\n  /** @override */\n\n\n  NearUInt64BE.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var buffer = uint8ArrayToBuffer(b);\n    var hi32 = buffer.readUInt32BE(offset);\n    var lo32 = buffer.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  };\n  /** @override */\n\n\n  NearUInt64BE.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var split = divmodInt64(src);\n    var buffer = uint8ArrayToBuffer(b);\n    buffer.writeUInt32BE(split.hi32, offset);\n    buffer.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  };\n\n  return NearUInt64BE;\n}(Layout);\n\nexports.NearUInt64BE = NearUInt64BE;\n/**\r\n * Represent a signed 64-bit integer in little-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.ns64|ns64}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar NearInt64 =\n/** @class */\nfunction (_super) {\n  __extends(NearInt64, _super);\n\n  function NearInt64(property) {\n    return _super.call(this, 8, property) || this;\n  }\n  /** @override */\n\n\n  NearInt64.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var buffer = uint8ArrayToBuffer(b);\n    var lo32 = buffer.readUInt32LE(offset);\n    var hi32 = buffer.readInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  };\n  /** @override */\n\n\n  NearInt64.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var split = divmodInt64(src);\n    var buffer = uint8ArrayToBuffer(b);\n    buffer.writeUInt32LE(split.lo32, offset);\n    buffer.writeInt32LE(split.hi32, offset + 4);\n    return 8;\n  };\n\n  return NearInt64;\n}(Layout);\n\nexports.NearInt64 = NearInt64;\n/**\r\n * Represent a signed 64-bit integer in big-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.ns64be|ns64be}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar NearInt64BE =\n/** @class */\nfunction (_super) {\n  __extends(NearInt64BE, _super);\n\n  function NearInt64BE(property) {\n    return _super.call(this, 8, property) || this;\n  }\n  /** @override */\n\n\n  NearInt64BE.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var buffer = uint8ArrayToBuffer(b);\n    var hi32 = buffer.readInt32BE(offset);\n    var lo32 = buffer.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  };\n  /** @override */\n\n\n  NearInt64BE.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var split = divmodInt64(src);\n    var buffer = uint8ArrayToBuffer(b);\n    buffer.writeInt32BE(split.hi32, offset);\n    buffer.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  };\n\n  return NearInt64BE;\n}(Layout);\n\nexports.NearInt64BE = NearInt64BE;\n/**\r\n * Represent a 32-bit floating point number in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f32|f32}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar Float =\n/** @class */\nfunction (_super) {\n  __extends(Float, _super);\n\n  function Float(property) {\n    return _super.call(this, 4, property) || this;\n  }\n  /** @override */\n\n\n  Float.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return uint8ArrayToBuffer(b).readFloatLE(offset);\n  };\n  /** @override */\n\n\n  Float.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    uint8ArrayToBuffer(b).writeFloatLE(src, offset);\n    return 4;\n  };\n\n  return Float;\n}(Layout);\n\nexports.Float = Float;\n/**\r\n * Represent a 32-bit floating point number in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f32be|f32be}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar FloatBE =\n/** @class */\nfunction (_super) {\n  __extends(FloatBE, _super);\n\n  function FloatBE(property) {\n    return _super.call(this, 4, property) || this;\n  }\n  /** @override */\n\n\n  FloatBE.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return uint8ArrayToBuffer(b).readFloatBE(offset);\n  };\n  /** @override */\n\n\n  FloatBE.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    uint8ArrayToBuffer(b).writeFloatBE(src, offset);\n    return 4;\n  };\n\n  return FloatBE;\n}(Layout);\n\nexports.FloatBE = FloatBE;\n/**\r\n * Represent a 64-bit floating point number in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f64|f64}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar Double =\n/** @class */\nfunction (_super) {\n  __extends(Double, _super);\n\n  function Double(property) {\n    return _super.call(this, 8, property) || this;\n  }\n  /** @override */\n\n\n  Double.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return uint8ArrayToBuffer(b).readDoubleLE(offset);\n  };\n  /** @override */\n\n\n  Double.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\n    return 8;\n  };\n\n  return Double;\n}(Layout);\n\nexports.Double = Double;\n/**\r\n * Represent a 64-bit floating point number in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f64be|f64be}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar DoubleBE =\n/** @class */\nfunction (_super) {\n  __extends(DoubleBE, _super);\n\n  function DoubleBE(property) {\n    return _super.call(this, 8, property) || this;\n  }\n  /** @override */\n\n\n  DoubleBE.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return uint8ArrayToBuffer(b).readDoubleBE(offset);\n  };\n  /** @override */\n\n\n  DoubleBE.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\n    return 8;\n  };\n\n  return DoubleBE;\n}(Layout);\n\nexports.DoubleBE = DoubleBE;\n/**\r\n * Represent a contiguous sequence of a specific layout as an Array.\r\n *\r\n * *Factory*: {@link module:Layout.seq|seq}\r\n *\r\n * @param {Layout} elementLayout - initializer for {@link\r\n * Sequence#elementLayout|elementLayout}.\r\n *\r\n * @param {(Number|ExternalLayout)} count - initializer for {@link\r\n * Sequence#count|count}.  The parameter must be either a positive\r\n * integer or an instance of {@link ExternalLayout}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar Sequence =\n/** @class */\nfunction (_super) {\n  __extends(Sequence, _super);\n\n  function Sequence(elementLayout, count, property) {\n    var _this = this;\n\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n\n    if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n      throw new TypeError('count must be non-negative integer ' + 'or an unsigned integer ExternalLayout');\n    }\n\n    var span = -1;\n\n    if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n      span = count * elementLayout.span;\n    }\n\n    _this = _super.call(this, span, property) || this;\n    /** The layout for individual elements of the sequence. */\n\n    _this.elementLayout = elementLayout;\n    /** The number of elements in the sequence.\r\n     *\r\n     * This will be either a non-negative integer or an instance of\r\n     * {@link ExternalLayout} for which {@link\r\n     * ExternalLayout#isCount|isCount()} is `true`. */\n\n    _this.count = count;\n    return _this;\n  }\n  /** @override */\n\n\n  Sequence.prototype.getSpan = function (b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var span = 0;\n    var count = this.count;\n\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n\n    if (0 < this.elementLayout.span) {\n      span = count * this.elementLayout.span;\n    } else {\n      var idx = 0;\n\n      while (idx < count) {\n        span += this.elementLayout.getSpan(b, offset + span);\n        ++idx;\n      }\n    }\n\n    return span;\n  };\n  /** @override */\n\n\n  Sequence.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var rv = [];\n    var i = 0;\n    var count = this.count;\n\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n\n    while (i < count) {\n      rv.push(this.elementLayout.decode(b, offset));\n      offset += this.elementLayout.getSpan(b, offset);\n      i += 1;\n    }\n\n    return rv;\n  };\n  /** Implement {@link Layout#encode|encode} for {@link Sequence}.\r\n   *\r\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\r\n   * the unused space in the buffer is left unchanged.  If `src` is\r\n   * longer than {@link Sequence#count|count} the unneeded elements are\r\n   * ignored.\r\n   *\r\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\r\n   * ExternalLayout} then the length of `src` will be encoded as the\r\n   * count after `src` is encoded. */\n\n\n  Sequence.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var elo = this.elementLayout;\n    var span = src.reduce(function (span, v) {\n      return span + elo.encode(v, b, offset + span);\n    }, 0);\n\n    if (this.count instanceof ExternalLayout) {\n      this.count.encode(src.length, b, offset);\n    }\n\n    return span;\n  };\n\n  return Sequence;\n}(Layout);\n\nexports.Sequence = Sequence;\n/**\r\n * Represent a contiguous sequence of arbitrary layout elements as an\r\n * Object.\r\n *\r\n * *Factory*: {@link module:Layout.struct|struct}\r\n *\r\n * **NOTE** The {@link Layout#span|span} of the structure is variable\r\n * if any layout in {@link Structure#fields|fields} has a variable\r\n * span.  When {@link Layout#encode|encoding} we must have a value for\r\n * all variable-length fields, or we wouldn't be able to figure out\r\n * how much space to use for storage.  We can only identify the value\r\n * for a field when it has a {@link Layout#property|property}.  As\r\n * such, although a structure may contain both unnamed fields and\r\n * variable-length fields, it cannot contain an unnamed\r\n * variable-length field.\r\n *\r\n * @param {Layout[]} fields - initializer for {@link\r\n * Structure#fields|fields}.  An error is raised if this contains a\r\n * variable-length field for which a {@link Layout#property|property}\r\n * is not defined.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @param {Boolean} [decodePrefixes] - initializer for {@link\r\n * Structure#decodePrefixes|property}.\r\n *\r\n * @throws {Error} - if `fields` contains an unnamed variable-length\r\n * layout.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar Structure =\n/** @class */\nfunction (_super) {\n  __extends(Structure, _super);\n\n  function Structure(fields, property, decodePrefixes) {\n    var _this = this;\n\n    if (!(Array.isArray(fields) && fields.reduce(function (acc, v) {\n      return acc && v instanceof Layout;\n    }, true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n\n    if ('boolean' === typeof property && undefined === decodePrefixes) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n    /* Verify absence of unnamed variable-length fields. */\n\n\n    for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {\n      var fd = fields_1[_i];\n\n      if (0 > fd.span && undefined === fd.property) {\n        throw new Error('fields cannot contain unnamed variable-length layout');\n      }\n    }\n\n    var span = -1;\n\n    try {\n      span = fields.reduce(function (span, fd) {\n        return span + fd.getSpan();\n      }, 0);\n    } catch (e) {// ignore error\n    }\n\n    _this = _super.call(this, span, property) || this;\n    /** The sequence of {@link Layout} values that comprise the\r\n     * structure.\r\n     *\r\n     * The individual elements need not be the same type, and may be\r\n     * either scalar or aggregate layouts.  If a member layout leaves\r\n     * its {@link Layout#property|property} undefined the\r\n     * corresponding region of the buffer associated with the element\r\n     * will not be mutated.\r\n     *\r\n     * @type {Layout[]} */\n\n    _this.fields = fields;\n    /** Control behavior of {@link Layout#decode|decode()} given short\r\n     * buffers.\r\n     *\r\n     * In some situations a structure many be extended with additional\r\n     * fields over time, with older installations providing only a\r\n     * prefix of the full structure.  If this property is `true`\r\n     * decoding will accept those buffers and leave subsequent fields\r\n     * undefined, as long as the buffer ends at a field boundary.\r\n     * Defaults to `false`. */\n\n    _this.decodePrefixes = !!decodePrefixes;\n    return _this;\n  }\n  /** @override */\n\n\n  Structure.prototype.getSpan = function (b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var span = 0;\n\n    try {\n      span = this.fields.reduce(function (span, fd) {\n        var fsp = fd.getSpan(b, offset);\n        offset += fsp;\n        return span + fsp;\n      }, 0);\n    } catch (e) {\n      throw new RangeError('indeterminate span');\n    }\n\n    return span;\n  };\n  /** @override */\n\n\n  Structure.prototype.decode = function (b, offset) {\n    checkUint8Array(b);\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var dest = this.makeDestinationObject();\n\n    for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\n      var fd = _a[_i];\n\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b, offset);\n      }\n\n      offset += fd.getSpan(b, offset);\n\n      if (this.decodePrefixes && b.length === offset) {\n        break;\n      }\n    }\n\n    return dest;\n  };\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\r\n   *\r\n   * If `src` is missing a property for a member with a defined {@link\r\n   * Layout#property|property} the corresponding region of the buffer is\r\n   * left unmodified. */\n\n\n  Structure.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var firstOffset = offset;\n    var lastOffset = 0;\n    var lastWrote = 0;\n\n    for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\n      var fd = _a[_i];\n      var span = fd.span;\n      lastWrote = 0 < span ? span : 0;\n\n      if (undefined !== fd.property) {\n        var fv = src[fd.property];\n\n        if (undefined !== fv) {\n          lastWrote = fd.encode(fv, b, offset);\n\n          if (0 > span) {\n            /* Read the as-encoded span, which is not necessarily the\r\n             * same as what we wrote. */\n            span = fd.getSpan(b, offset);\n          }\n        }\n      }\n\n      lastOffset = offset;\n      offset += span;\n    }\n    /* Use (lastOffset + lastWrote) instead of offset because the last\r\n     * item may have had a dynamic length and we don't want to include\r\n     * the padding between it and the end of the space reserved for\r\n     * it. */\n\n\n    return lastOffset + lastWrote - firstOffset;\n  };\n  /** @override */\n\n\n  Structure.prototype.fromArray = function (values) {\n    var dest = this.makeDestinationObject();\n\n    for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\n      var fd = _a[_i];\n\n      if (undefined !== fd.property && 0 < values.length) {\n        dest[fd.property] = values.shift();\n      }\n    }\n\n    return dest;\n  };\n  /**\r\n   * Get access to the layout of a given property.\r\n   *\r\n   * @param {String} property - the structure member of interest.\r\n   *\r\n   * @return {Layout} - the layout associated with `property`, or\r\n   * undefined if there is no such property.\r\n   */\n\n\n  Structure.prototype.layoutFor = function (property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n\n    for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\n      var fd = _a[_i];\n\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n\n    return undefined;\n  };\n  /**\r\n   * Get the offset of a structure member.\r\n   *\r\n   * @param {String} property - the structure member of interest.\r\n   *\r\n   * @return {Number} - the offset in bytes to the start of `property`\r\n   * within the structure, or undefined if `property` is not a field\r\n   * within the structure.  If the property is a member but follows a\r\n   * variable-length structure member a negative number will be\r\n   * returned.\r\n   */\n\n\n  Structure.prototype.offsetOf = function (property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n\n    var offset = 0;\n\n    for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\n      var fd = _a[_i];\n\n      if (fd.property === property) {\n        return offset;\n      }\n\n      if (0 > fd.span) {\n        offset = -1;\n      } else if (0 <= offset) {\n        offset += fd.span;\n      }\n    }\n\n    return undefined;\n  };\n\n  return Structure;\n}(Layout);\n\nexports.Structure = Structure;\n/**\r\n * An object that can provide a {@link\r\n * Union#discriminator|discriminator} API for {@link Union}.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support the {@link\r\n * UnionDiscriminator#encode|encode} or {@link\r\n * UnionDiscriminator#decode|decode} functions.\r\n *\r\n * @param {string} [property] - Default for {@link\r\n * UnionDiscriminator#property|property}.\r\n *\r\n * @abstract\r\n */\n\nvar UnionDiscriminator =\n/** @class */\nfunction () {\n  function UnionDiscriminator(property) {\n    /** The {@link Layout#property|property} to be used when the\r\n     * discriminator is referenced in isolation (generally when {@link\r\n     * Union#decode|Union decode} cannot delegate to a specific\r\n     * variant). */\n    this.property = property;\n  }\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\r\n   *\r\n   * The implementation of this method need not reference the buffer if\r\n   * variant information is available through other means. */\n\n\n  UnionDiscriminator.prototype.decode = function (b, offset) {\n    throw new Error('UnionDiscriminator is abstract');\n  };\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\r\n   *\r\n   * The implementation of this method need not store the value if\r\n   * variant information is maintained through other means. */\n\n\n  UnionDiscriminator.prototype.encode = function (src, b, offset) {\n    throw new Error('UnionDiscriminator is abstract');\n  };\n\n  return UnionDiscriminator;\n}();\n\nexports.UnionDiscriminator = UnionDiscriminator;\n/**\r\n * An object that can provide a {@link\r\n * UnionDiscriminator|discriminator API} for {@link Union} using an\r\n * unsigned integral {@link Layout} instance located either inside or\r\n * outside the union.\r\n *\r\n * @param {ExternalLayout} layout - initializes {@link\r\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\r\n * ExternalLayout#isCount|isCount()}.\r\n *\r\n * @param {string} [property] - Default for {@link\r\n * UnionDiscriminator#property|property}, superseding the property\r\n * from `layout`, but defaulting to `variant` if neither `property`\r\n * nor layout provide a property name.\r\n *\r\n * @augments {UnionDiscriminator}\r\n */\n\nvar UnionLayoutDiscriminator =\n/** @class */\nfunction (_super) {\n  __extends(UnionLayoutDiscriminator, _super);\n\n  function UnionLayoutDiscriminator(layout, property) {\n    var _this = this;\n\n    if (!(layout instanceof ExternalLayout && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n\n    _this = _super.call(this, property || layout.property || 'variant') || this;\n    /** The {@link ExternalLayout} used to access the discriminator\r\n     * value. */\n\n    _this.layout = layout;\n    return _this;\n  }\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n\n\n  UnionLayoutDiscriminator.prototype.decode = function (b, offset) {\n    return this.layout.decode(b, offset);\n  };\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n\n\n  UnionLayoutDiscriminator.prototype.encode = function (src, b, offset) {\n    return this.layout.encode(src, b, offset);\n  };\n\n  return UnionLayoutDiscriminator;\n}(UnionDiscriminator);\n\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n/**\r\n * Represent any number of span-compatible layouts.\r\n *\r\n * *Factory*: {@link module:Layout.union|union}\r\n *\r\n * If the union has a {@link Union#defaultLayout|default layout} that\r\n * layout must have a non-negative {@link Layout#span|span}.  The span\r\n * of a fixed-span union includes its {@link\r\n * Union#discriminator|discriminator} if the variant is a {@link\r\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\r\n * of its {@link Union#defaultLayout|default layout}.\r\n *\r\n * If the union does not have a default layout then the encoded span\r\n * of the union depends on the encoded span of its variant (which may\r\n * be fixed or variable).\r\n *\r\n * {@link VariantLayout#layout|Variant layout}s are added through\r\n * {@link Union#addVariant|addVariant}.  If the union has a default\r\n * layout, the span of the {@link VariantLayout#layout|layout\r\n * contained by the variant} must not exceed the span of the {@link\r\n * Union#defaultLayout|default layout} (minus the span of a {@link\r\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\r\n * span of the variant will equal the span of the union itself.\r\n *\r\n * The variant for a buffer can only be identified from the {@link\r\n * Union#discriminator|discriminator} {@link\r\n * UnionDiscriminator#property|property} (in the case of the {@link\r\n * Union#defaultLayout|default layout}), or by using {@link\r\n * Union#getVariant|getVariant} and examining the resulting {@link\r\n * VariantLayout} instance.\r\n *\r\n * A variant compatible with a JavaScript object can be identified\r\n * using {@link Union#getSourceVariant|getSourceVariant}.\r\n *\r\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\r\n * identify the layout used to interpret the union contents.  The\r\n * parameter must be an instance of {@link UnionDiscriminator}, an\r\n * {@link ExternalLayout} that satisfies {@link\r\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\r\n * UIntBE}).  When a non-external layout element is passed the layout\r\n * appears at the start of the union.  In all cases the (synthesized)\r\n * {@link UnionDiscriminator} instance is recorded as {@link\r\n * Union#discriminator|discriminator}.\r\n *\r\n * @param {(Layout|null)} defaultLayout - initializer for {@link\r\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\r\n * If `null` there is no default layout: the union has data-dependent\r\n * length and attempts to decode or encode unrecognized variants will\r\n * throw an exception.  A {@link Layout} instance must have a\r\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\r\n * Layout#property|property} the {@link\r\n * Union#defaultLayout|defaultLayout} will be a {@link\r\n * Layout#replicate|replica} with property `content`.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar Union =\n/** @class */\nfunction (_super) {\n  __extends(Union, _super);\n\n  function Union(discr, defaultLayout, property) {\n    var _this = this;\n\n    var upv = discr instanceof UInt || discr instanceof UIntBE;\n    var discriminator;\n\n    if (upv) {\n      discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if (discr instanceof ExternalLayout && discr.isCount()) {\n      discriminator = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator ' + 'or an unsigned integer layout');\n    } else {\n      discriminator = discr;\n    }\n\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n\n    if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n    /* The union span can be estimated only if there's a default\r\n     * layout.  The union spans its default layout, plus any prefix\r\n     * variant layout.  By construction both layouts, if present, have\r\n     * non-negative span. */\n\n\n    var span = -1;\n\n    if (defaultLayout) {\n      span = defaultLayout.span;\n\n      if (0 <= span && upv) {\n        span += discriminator.layout.span;\n      }\n    }\n\n    _this = _super.call(this, span, property) || this;\n    /** The interface for the discriminator value in isolation.\r\n     *\r\n     * This a {@link UnionDiscriminator} either passed to the\r\n     * constructor or synthesized from the `discr` constructor\r\n     * argument.  {@link\r\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\r\n     * `true` iff the `discr` parameter was a non-offset {@link\r\n     * Layout} instance. */\n\n    _this.discriminator = discriminator;\n    /** `true` if the {@link Union#discriminator|discriminator} is the\r\n     * first field in the union.\r\n     *\r\n     * If `false` the discriminator is obtained from somewhere\r\n     * else. */\n\n    _this.usesPrefixDiscriminator = upv;\n    /** The layout for non-discriminator content when the value of the\r\n     * discriminator is not recognized.\r\n     *\r\n     * This is the value passed to the constructor.  It is\r\n     * structurally equivalent to the second component of {@link\r\n     * Union#layout|layout} but may have a different property\r\n     * name. */\n\n    _this.defaultLayout = defaultLayout;\n    /** A registry of allowed variants.\r\n     *\r\n     * The keys are unsigned integers which should be compatible with\r\n     * {@link Union.discriminator|discriminator}.  The property value\r\n     * is the corresponding {@link VariantLayout} instances assigned\r\n     * to this union by {@link Union#addVariant|addVariant}.\r\n     *\r\n     * **NOTE** The registry remains mutable so that variants can be\r\n     * {@link Union#addVariant|added} at any time.  Users should not\r\n     * manipulate the content of this property. */\n\n    _this.registry = {};\n    /* Private variable used when invoking getSourceVariant */\n\n    var boundGetSourceVariant = _this.defaultGetSourceVariant.bind(_this);\n    /** Function to infer the variant selected by a source object.\r\n     *\r\n     * Defaults to {@link\r\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\r\n     * be overridden using {@link\r\n     * Union#configGetSourceVariant|configGetSourceVariant}.\r\n     *\r\n     * @param {Object} src - as with {@link\r\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\r\n     *\r\n     * @returns {(undefined|VariantLayout)} The default variant\r\n     * (`undefined`) or first registered variant that uses a property\r\n     * available in `src`. */\n\n\n    _this.getSourceVariant = function (src) {\n      return boundGetSourceVariant(src);\n    };\n    /** Function to override the implementation of {@link\r\n     * Union#getSourceVariant|getSourceVariant}.\r\n     *\r\n     * Use this if the desired variant cannot be identified using the\r\n     * algorithm of {@link\r\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\r\n     *\r\n     * **NOTE** The provided function will be invoked bound to this\r\n     * Union instance, providing local access to {@link\r\n     * Union#registry|registry}.\r\n     *\r\n     * @param {Function} gsv - a function that follows the API of\r\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n\n\n    _this.configGetSourceVariant = function (gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n\n    return _this;\n  }\n  /** @override */\n\n\n  Union.prototype.getSpan = function (b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Default layouts always have non-negative span, so we don't have\r\n     * one and we have to recognize the variant which will in turn\r\n     * determine the span. */\n\n\n    var vlo = this.getVariant(b, offset);\n\n    if (!vlo) {\n      throw new Error('unable to determine span for unrecognized variant');\n    }\n\n    return vlo.getSpan(b, offset);\n  };\n  /**\r\n   * Method to infer a registered Union variant compatible with `src`.\r\n   *\r\n   * The first satisfied rule in the following sequence defines the\r\n   * return value:\r\n   * * If `src` has properties matching the Union discriminator and\r\n   *   the default layout, `undefined` is returned regardless of the\r\n   *   value of the discriminator property (this ensures the default\r\n   *   layout will be used);\r\n   * * If `src` has a property matching the Union discriminator, the\r\n   *   value of the discriminator identifies a registered variant, and\r\n   *   either (a) the variant has no layout, or (b) `src` has the\r\n   *   variant's property, then the variant is returned (because the\r\n   *   source satisfies the constraints of the variant it identifies);\r\n   * * If `src` does not have a property matching the Union\r\n   *   discriminator, but does have a property matching a registered\r\n   *   variant, then the variant is returned (because the source\r\n   *   matches a variant without an explicit conflict);\r\n   * * An error is thrown (because we either can't identify a variant,\r\n   *   or we were explicitly told the variant but can't satisfy it).\r\n   *\r\n   * @param {Object} src - an object presumed to be compatible with\r\n   * the content of the Union.\r\n   *\r\n   * @return {(undefined|VariantLayout)} - as described above.\r\n   *\r\n   * @throws {Error} - if `src` cannot be associated with a default or\r\n   * registered variant.\r\n   */\n\n\n  Union.prototype.defaultGetSourceVariant = function (src) {\n    if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n      if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n        return undefined;\n      }\n\n      var vlo = this.registry[src[this.discriminator.property]];\n\n      if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {\n        return vlo;\n      }\n    } else {\n      for (var tag in this.registry) {\n        var vlo = this.registry[tag];\n\n        if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n          return vlo;\n        }\n      }\n    }\n\n    throw new Error('unable to infer src variant');\n  };\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\r\n   *\r\n   * If the variant is {@link Union#addVariant|registered} the return\r\n   * value is an instance of that variant, with no explicit\r\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\r\n   * layout} is used to decode the content. */\n\n\n  Union.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var dest;\n    var dlo = this.discriminator;\n    var discr = dlo.decode(b, offset);\n    var clo = this.registry[discr];\n\n    if (undefined === clo) {\n      var defaultLayout = this.defaultLayout;\n      var contentOffset = 0;\n\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n\n      dest = this.makeDestinationObject();\n      dest[dlo.property] = discr;\n      dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\n    } else {\n      dest = clo.decode(b, offset);\n    }\n\n    return dest;\n  };\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\r\n   *\r\n   * This API assumes the `src` object is consistent with the union's\r\n   * {@link Union#defaultLayout|default layout}.  To encode variants\r\n   * use the appropriate variant-specific {@link VariantLayout#encode}\r\n   * method. */\n\n\n  Union.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var vlo = this.getSourceVariant(src);\n\n    if (undefined === vlo) {\n      var dlo = this.discriminator; // this.defaultLayout is not undefined when vlo is undefined\n\n      var clo = this.defaultLayout;\n      var contentOffset = 0;\n\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n\n      dlo.encode(src[dlo.property], b, offset); // clo.property is not undefined when vlo is undefined\n\n      return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n    }\n\n    return vlo.encode(src, b, offset);\n  };\n  /** Register a new variant structure within a union.  The newly\r\n   * created variant is returned.\r\n   *\r\n   * @param {Number} variant - initializer for {@link\r\n   * VariantLayout#variant|variant}.\r\n   *\r\n   * @param {Layout} layout - initializer for {@link\r\n   * VariantLayout#layout|layout}.\r\n   *\r\n   * @param {String} property - initializer for {@link\r\n   * Layout#property|property}.\r\n   *\r\n   * @return {VariantLayout} */\n\n\n  Union.prototype.addVariant = function (variant, layout, property) {\n    var rv = new VariantLayout(this, variant, layout, property);\n    this.registry[variant] = rv;\n    return rv;\n  };\n  /**\r\n   * Get the layout associated with a registered variant.\r\n   *\r\n   * If `vb` does not produce a registered variant the function returns\r\n   * `undefined`.\r\n   *\r\n   * @param {(Number|Uint8Array)} vb - either the variant number, or a\r\n   * buffer from which the discriminator is to be read.\r\n   *\r\n   * @param {Number} offset - offset into `vb` for the start of the\r\n   * union.  Used only when `vb` is an instance of {Uint8Array}.\r\n   *\r\n   * @return {({VariantLayout}|undefined)}\r\n   */\n\n\n  Union.prototype.getVariant = function (vb, offset) {\n    var variant;\n\n    if (vb instanceof Uint8Array) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      variant = this.discriminator.decode(vb, offset);\n    } else {\n      variant = vb;\n    }\n\n    return this.registry[variant];\n  };\n\n  return Union;\n}(Layout);\n\nexports.Union = Union;\n/**\r\n * Represent a specific variant within a containing union.\r\n *\r\n * **NOTE** The {@link Layout#span|span} of the variant may include\r\n * the span of the {@link Union#discriminator|discriminator} used to\r\n * identify it, but values read and written using the variant strictly\r\n * conform to the content of {@link VariantLayout#layout|layout}.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.  Use\r\n * the union {@link Union#addVariant|addVariant} helper method.\r\n *\r\n * @param {Union} union - initializer for {@link\r\n * VariantLayout#union|union}.\r\n *\r\n * @param {Number} variant - initializer for {@link\r\n * VariantLayout#variant|variant}.\r\n *\r\n * @param {Layout} [layout] - initializer for {@link\r\n * VariantLayout#layout|layout}.  If absent the variant carries no\r\n * data.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.  Unlike many other layouts, variant\r\n * layouts normally include a property name so they can be identified\r\n * within their containing {@link Union}.  The property identifier may\r\n * be absent only if `layout` is is absent.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar VariantLayout =\n/** @class */\nfunction (_super) {\n  __extends(VariantLayout, _super);\n\n  function VariantLayout(union, variant, layout, property) {\n    var _this = this;\n\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n\n    if (!Number.isInteger(variant) || 0 > variant) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n\n    if ('string' === typeof layout && undefined === property) {\n      property = layout;\n      layout = null;\n    }\n\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n\n      if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n\n    var span = union.span;\n\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n\n      if (0 <= span && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n\n    _this = _super.call(this, span, property) || this;\n    /** The {@link Union} to which this variant belongs. */\n\n    _this.union = union;\n    /** The unsigned integral value identifying this variant within\r\n     * the {@link Union#discriminator|discriminator} of the containing\r\n     * union. */\n\n    _this.variant = variant;\n    /** The {@link Layout} to be used when reading/writing the\r\n     * non-discriminator part of the {@link\r\n     * VariantLayout#union|union}.  If `null` the variant carries no\r\n     * data. */\n\n    _this.layout = layout || null;\n    return _this;\n  }\n  /** @override */\n\n\n  VariantLayout.prototype.getSpan = function (b, offset) {\n    if (0 <= this.span) {\n      /* Will be equal to the containing union span if that is not\r\n       * variable. */\n      return this.span;\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var contentOffset = 0;\n\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    /* Span is defined solely by the variant (and prefix discriminator) */\n\n\n    var span = 0;\n\n    if (this.layout) {\n      span = this.layout.getSpan(b, offset + contentOffset);\n    }\n\n    return contentOffset + span;\n  };\n  /** @override */\n\n\n  VariantLayout.prototype.decode = function (b, offset) {\n    var dest = this.makeDestinationObject();\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    if (this !== this.union.getVariant(b, offset)) {\n      throw new Error('variant mismatch');\n    }\n\n    var contentOffset = 0;\n\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    } // VariantLayout property is never undefined\n\n\n    var property = this.property;\n\n    if (this.layout) {\n      dest[property] = this.layout.decode(b, offset + contentOffset);\n    } else if (property) {\n      dest[property] = true;\n    } else if (this.union.usesPrefixDiscriminator) {\n      dest[this.union.discriminator.property] = this.variant;\n    }\n\n    return dest;\n  };\n  /** @override */\n\n\n  VariantLayout.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var contentOffset = 0;\n\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    } // VariantLayout property is never undefined\n\n\n    var property = this.property;\n\n    if (this.layout && !Object.prototype.hasOwnProperty.call(src, property)) {\n      throw new TypeError('variant lacks property ' + property);\n    }\n\n    this.union.discriminator.encode(this.variant, b, offset);\n    var span = contentOffset;\n\n    if (this.layout) {\n      this.layout.encode(src[property], b, offset + contentOffset);\n      span += this.layout.getSpan(b, offset + contentOffset);\n\n      if (0 <= this.union.span && span > this.union.span) {\n        throw new Error('encoded variant overruns containing union');\n      }\n    }\n\n    return span;\n  };\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\r\n   * VariantLayout#layout|layout}. */\n\n\n  VariantLayout.prototype.fromArray = function (values) {\n    if (this.layout) {\n      return this.layout.fromArray(values);\n    }\n\n    return undefined;\n  };\n\n  return VariantLayout;\n}(Layout);\n\nexports.VariantLayout = VariantLayout;\n/** JavaScript chose to define bitwise operations as operating on\r\n * signed 32-bit values in 2's complement form, meaning any integer\r\n * with bit 31 set is going to look negative.  For right shifts that's\r\n * not a problem, because `>>>` is a logical shift, but for every\r\n * other bitwise operator we have to compensate for possible negative\r\n * results. */\n\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n\n  return v;\n}\n/**\r\n * Contain a sequence of bit fields as an unsigned integer.\r\n *\r\n * *Factory*: {@link module:Layout.bits|bits}\r\n *\r\n * This is a container element; within it there are {@link BitField}\r\n * instances that provide the extracted properties.  The container\r\n * simply defines the aggregate representation and its bit ordering.\r\n * The representation is an object containing properties with numeric\r\n * or {@link Boolean} values.\r\n *\r\n * {@link BitField}s are added with the {@link\r\n * BitStructure#addField|addField} and {@link\r\n * BitStructure#addBoolean|addBoolean} methods.\r\n\r\n * @param {Layout} word - initializer for {@link\r\n * BitStructure#word|word}.  The parameter must be an instance of\r\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\r\n *\r\n * @param {bool} [msb] - `true` if the bit numbering starts at the\r\n * most significant bit of the containing word; `false` (default) if\r\n * it starts at the least significant bit of the containing word.  If\r\n * the parameter at this position is a string and `property` is\r\n * `undefined` the value of this argument will instead be used as the\r\n * value of `property`.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\n\nvar BitStructure =\n/** @class */\nfunction (_super) {\n  __extends(BitStructure, _super);\n\n  function BitStructure(word, msb, property) {\n    var _this = this;\n\n    if (!(word instanceof UInt || word instanceof UIntBE)) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n\n    if ('string' === typeof msb && undefined === property) {\n      property = msb;\n      msb = false;\n    }\n\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n\n    _this = _super.call(this, word.span, property) || this;\n    /** The layout used for the packed value.  {@link BitField}\r\n     * instances are packed sequentially depending on {@link\r\n     * BitStructure#msb|msb}. */\n\n    _this.word = word;\n    /** Whether the bit sequences are packed starting at the most\r\n     * significant bit growing down (`true`), or the least significant\r\n     * bit growing up (`false`).\r\n     *\r\n     * **NOTE** Regardless of this value, the least significant bit of\r\n     * any {@link BitField} value is the least significant bit of the\r\n     * corresponding section of the packed value. */\n\n    _this.msb = !!msb;\n    /** The sequence of {@link BitField} layouts that comprise the\r\n     * packed structure.\r\n     *\r\n     * **NOTE** The array remains mutable to allow fields to be {@link\r\n     * BitStructure#addField|added} after construction.  Users should\r\n     * not manipulate the content of this property.*/\n\n    _this.fields = [];\n    /* Storage for the value.  Capture a variable instead of using an\r\n     * instance property because we don't want anything to change the\r\n     * value without going through the mutator. */\n\n    var value = 0;\n\n    _this._packedSetValue = function (v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n\n    _this._packedGetValue = function () {\n      return value;\n    };\n\n    return _this;\n  }\n  /** @override */\n\n\n  BitStructure.prototype.decode = function (b, offset) {\n    var dest = this.makeDestinationObject();\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var value = this.word.decode(b, offset);\n\n    this._packedSetValue(value);\n\n    for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\n      var fd = _a[_i];\n\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(value);\n      }\n    }\n\n    return dest;\n  };\n  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\r\n   *\r\n   * If `src` is missing a property for a member with a defined {@link\r\n   * Layout#property|property} the corresponding region of the packed\r\n   * value is left unmodified.  Unused bits are also left unmodified. */\n\n\n  BitStructure.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var value = this.word.decode(b, offset);\n\n    this._packedSetValue(value);\n\n    for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\n      var fd = _a[_i];\n\n      if (undefined !== fd.property) {\n        var fv = src[fd.property];\n\n        if (undefined !== fv) {\n          fd.encode(fv);\n        }\n      }\n    }\n\n    return this.word.encode(this._packedGetValue(), b, offset);\n  };\n  /** Register a new bitfield with a containing bit structure.  The\r\n   * resulting bitfield is returned.\r\n   *\r\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\r\n   *\r\n   * @param {string} property - initializer for {@link\r\n   * Layout#property|property}.\r\n   *\r\n   * @return {BitField} */\n\n\n  BitStructure.prototype.addField = function (bits, property) {\n    var bf = new BitField(this, bits, property);\n    this.fields.push(bf);\n    return bf;\n  };\n  /** As with {@link BitStructure#addField|addField} for single-bit\r\n   * fields with `boolean` value representation.\r\n   *\r\n   * @param {string} property - initializer for {@link\r\n   * Layout#property|property}.\r\n   *\r\n   * @return {Boolean} */\n\n\n  BitStructure.prototype.addBoolean = function (property) {\n    // This is my Boolean, not the Javascript one.\n    // eslint-disable-next-line no-new-wrappers\n    var bf = new Boolean(this, property);\n    this.fields.push(bf);\n    return bf;\n  };\n  /**\r\n   * Get access to the bit field for a given property.\r\n   *\r\n   * @param {String} property - the bit field of interest.\r\n   *\r\n   * @return {BitField} - the field associated with `property`, or\r\n   * undefined if there is no such property.\r\n   */\n\n\n  BitStructure.prototype.fieldFor = function (property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n\n    for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\n      var fd = _a[_i];\n\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n\n    return undefined;\n  };\n\n  return BitStructure;\n}(Layout);\n\nexports.BitStructure = BitStructure;\n/**\r\n * Represent a sequence of bits within a {@link BitStructure}.\r\n *\r\n * All bit field values are represented as unsigned integers.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.\r\n * Use the container {@link BitStructure#addField|addField} helper\r\n * method.\r\n *\r\n * **NOTE** BitField instances are not instances of {@link Layout}\r\n * since {@link Layout#span|span} measures 8-bit units.\r\n *\r\n * @param {BitStructure} container - initializer for {@link\r\n * BitField#container|container}.\r\n *\r\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n */\n\nvar BitField =\n/** @class */\nfunction () {\n  function BitField(container, bits, property) {\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n\n    if (!Number.isInteger(bits) || 0 >= bits) {\n      throw new TypeError('bits must be positive integer');\n    }\n\n    var totalBits = 8 * container.span;\n    var usedBits = container.fields.reduce(function (sum, fd) {\n      return sum + fd.bits;\n    }, 0);\n\n    if (bits + usedBits > totalBits) {\n      throw new Error('bits too long for span remainder (' + (totalBits - usedBits) + ' of ' + totalBits + ' remain)');\n    }\n    /** The {@link BitStructure} instance to which this bit field\r\n     * belongs. */\n\n\n    this.container = container;\n    /** The span of this value in bits. */\n\n    this.bits = bits;\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\r\n     * that fit within the field.\r\n     *\r\n     * That is, it masks a value that has not yet been shifted into\r\n     * position within its containing packed integer. */\n\n    this.valueMask = (1 << bits) - 1;\n\n    if (32 === bits) {\n      // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n    /** The offset of the value within the containing packed unsigned\r\n     * integer.  The least significant bit of the packed value is at\r\n     * offset zero, regardless of bit ordering used. */\n\n\n    this.start = usedBits;\n\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n    /** A mask of {@link BitField#bits|bits} isolating the field value\r\n     * within the containing packed unsigned integer. */\n\n\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n    /** The property name used when this bitfield is represented in an\r\n     * Object.\r\n     *\r\n     * Intended to be functionally equivalent to {@link\r\n     * Layout#property}.\r\n     *\r\n     * If left undefined the corresponding span of bits will be\r\n     * treated as padding: it will not be mutated by {@link\r\n     * Layout#encode|encode} nor represented as a property in the\r\n     * decoded Object. */\n\n    this.property = property;\n  }\n  /** Store a value into the corresponding subsequence of the containing\r\n   * bit field. */\n\n\n  BitField.prototype.decode = function (b, offset) {\n    var word = this.container._packedGetValue();\n\n    var wordValue = fixBitwiseResult(word & this.wordMask);\n    var value = wordValue >>> this.start;\n    return value;\n  };\n  /** Store a value into the corresponding subsequence of the containing\r\n   * bit field.\r\n   *\r\n   * **NOTE** This is not a specialization of {@link\r\n   * Layout#encode|Layout.encode} and there is no return value. */\n\n\n  BitField.prototype.encode = function (value) {\n    if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n      throw new TypeError(nameWithProperty('BitField.encode', this) + ' value must be integer not exceeding ' + this.valueMask);\n    }\n\n    var word = this.container._packedGetValue();\n\n    var wordValue = fixBitwiseResult(value << this.start);\n\n    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n  };\n\n  return BitField;\n}();\n\nexports.BitField = BitField;\n/**\r\n * Represent a single bit within a {@link BitStructure} as a\r\n * JavaScript boolean.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.\r\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\r\n * method.\r\n *\r\n * @param {BitStructure} container - initializer for {@link\r\n * BitField#container|container}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {BitField}\r\n */\n\n/* eslint-disable no-extend-native */\n\nvar Boolean =\n/** @class */\nfunction (_super) {\n  __extends(Boolean, _super);\n\n  function Boolean(container, property) {\n    return _super.call(this, container, 1, property) || this;\n  }\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\r\n   *\r\n   * @returns {boolean} */\n\n\n  Boolean.prototype.decode = function (b, offset) {\n    return !!BitField.prototype.decode.call(this, b, offset);\n  };\n  /** @override */\n\n\n  Boolean.prototype.encode = function (value) {\n    if ('boolean' === typeof value) {\n      // BitField requires integer values\n      value = +value;\n    }\n\n    return BitField.prototype.encode.call(this, value);\n  };\n\n  return Boolean;\n}(BitField);\n\nexports.Boolean = Boolean;\n/* eslint-enable no-extend-native */\n\n/**\r\n * Contain a fixed-length block of arbitrary data, represented as a\r\n * Uint8Array.\r\n *\r\n * *Factory*: {@link module:Layout.blob|blob}\r\n *\r\n * @param {(Number|ExternalLayout)} length - initializes {@link\r\n * Blob#length|length}.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar Blob =\n/** @class */\nfunction (_super) {\n  __extends(Blob, _super);\n\n  function Blob(length, property) {\n    var _this = this;\n\n    if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n      throw new TypeError('length must be positive integer ' + 'or an unsigned integer ExternalLayout');\n    }\n\n    var span = -1;\n\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n\n    _this = _super.call(this, span, property) || this;\n    /** The number of bytes in the blob.\r\n     *\r\n     * This may be a non-negative integer, or an instance of {@link\r\n     * ExternalLayout} that satisfies {@link\r\n     * ExternalLayout#isCount|isCount()}. */\n\n    _this.length = length;\n    return _this;\n  }\n  /** @override */\n\n\n  Blob.prototype.getSpan = function (b, offset) {\n    var span = this.span;\n\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n\n    return span;\n  };\n  /** @override */\n\n\n  Blob.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var span = this.span;\n\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n\n    return uint8ArrayToBuffer(b).slice(offset, offset + span);\n  };\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\r\n   *\r\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\r\n   * ExternalLayout} then the length of `src` will be encoded as the\r\n   * count after `src` is encoded. */\n\n\n  Blob.prototype.encode = function (src, b, offset) {\n    var span = this.length;\n\n    if (this.length instanceof ExternalLayout) {\n      span = src.length;\n    }\n\n    if (!(src instanceof Uint8Array && span === src.length)) {\n      throw new TypeError(nameWithProperty('Blob.encode', this) + ' requires (length ' + span + ') Uint8Array as src');\n    }\n\n    if (offset + span > b.length) {\n      throw new RangeError('encoding overruns Uint8Array');\n    }\n\n    var srcBuffer = uint8ArrayToBuffer(src);\n    uint8ArrayToBuffer(b).write(srcBuffer.toString('hex'), offset, span, 'hex');\n\n    if (this.length instanceof ExternalLayout) {\n      this.length.encode(span, b, offset);\n    }\n\n    return span;\n  };\n\n  return Blob;\n}(Layout);\n\nexports.Blob = Blob;\n/**\r\n * Contain a `NUL`-terminated UTF8 string.\r\n *\r\n * *Factory*: {@link module:Layout.cstr|cstr}\r\n *\r\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\r\n * not be correctly decoded by this layout.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar CString =\n/** @class */\nfunction (_super) {\n  __extends(CString, _super);\n\n  function CString(property) {\n    return _super.call(this, -1, property) || this;\n  }\n  /** @override */\n\n\n  CString.prototype.getSpan = function (b, offset) {\n    checkUint8Array(b);\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var idx = offset;\n\n    while (idx < b.length && 0 !== b[idx]) {\n      idx += 1;\n    }\n\n    return 1 + idx - offset;\n  };\n  /** @override */\n\n\n  CString.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var span = this.getSpan(b, offset);\n    return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString('utf-8');\n  };\n  /** @override */\n\n\n  CString.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\r\n     * \"utf8-encoding\" below actually allocate a buffer of length\r\n     * src */\n\n\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n\n    var srcb = buffer_1.Buffer.from(src, 'utf8');\n    var span = srcb.length;\n\n    if (offset + span > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n\n    var buffer = uint8ArrayToBuffer(b);\n    srcb.copy(buffer, offset);\n    buffer[offset + span] = 0;\n    return span + 1;\n  };\n\n  return CString;\n}(Layout);\n\nexports.CString = CString;\n/**\r\n * Contain a UTF8 string with implicit length.\r\n *\r\n * *Factory*: {@link module:Layout.utf8|utf8}\r\n *\r\n * **NOTE** Because the length is implicit in the size of the buffer\r\n * this layout should be used only in isolation, or in a situation\r\n * where the length can be expressed by operating on a slice of the\r\n * containing buffer.\r\n *\r\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\r\n * string content.  If not provided there is no bound on the allowed\r\n * content.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar UTF8 =\n/** @class */\nfunction (_super) {\n  __extends(UTF8, _super);\n\n  function UTF8(maxSpan, property) {\n    var _this = this;\n\n    if ('string' === typeof maxSpan && undefined === property) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n\n    _this = _super.call(this, -1, property) || this;\n    /** The maximum span of the layout in bytes.\r\n     *\r\n     * Positive values are generally expected.  Zero is abnormal.\r\n     * Attempts to encode or decode a value that exceeds this length\r\n     * will throw a `RangeError`.\r\n     *\r\n     * A negative value indicates that there is no bound on the length\r\n     * of the content. */\n\n    _this.maxSpan = maxSpan;\n    return _this;\n  }\n  /** @override */\n\n\n  UTF8.prototype.getSpan = function (b, offset) {\n    checkUint8Array(b);\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return b.length - offset;\n  };\n  /** @override */\n\n\n  UTF8.prototype.decode = function (b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    var span = this.getSpan(b, offset);\n\n    if (0 <= this.maxSpan && this.maxSpan < span) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n\n    return uint8ArrayToBuffer(b).slice(offset, offset + span).toString('utf-8');\n  };\n  /** @override */\n\n\n  UTF8.prototype.encode = function (src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\r\n     * \"utf8-encoding\" below actually allocate a buffer of length\r\n     * src */\n\n\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n\n    var srcb = buffer_1.Buffer.from(src, 'utf8');\n    var span = srcb.length;\n\n    if (0 <= this.maxSpan && this.maxSpan < span) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n\n    if (offset + span > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n\n    srcb.copy(uint8ArrayToBuffer(b), offset);\n    return span;\n  };\n\n  return UTF8;\n}(Layout);\n\nexports.UTF8 = UTF8;\n/**\r\n * Contain a constant value.\r\n *\r\n * This layout may be used in cases where a JavaScript value can be\r\n * inferred without an expression in the binary encoding.  An example\r\n * would be a {@link VariantLayout|variant layout} where the content\r\n * is implied by the union {@link Union#discriminator|discriminator}.\r\n *\r\n * @param {Object|Number|String} value - initializer for {@link\r\n * Constant#value|value}.  If the value is an object (or array) and\r\n * the application intends the object to remain unchanged regardless\r\n * of what is done to values decoded by this layout, the value should\r\n * be frozen prior passing it to this constructor.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\n\nvar Constant =\n/** @class */\nfunction (_super) {\n  __extends(Constant, _super);\n\n  function Constant(value, property) {\n    var _this = _super.call(this, 0, property) || this;\n    /** The value produced by this constant when the layout is {@link\r\n     * Constant#decode|decoded}.\r\n     *\r\n     * Any JavaScript value including `null` and `undefined` is\r\n     * permitted.\r\n     *\r\n     * **WARNING** If `value` passed in the constructor was not\r\n     * frozen, it is possible for users of decoded values to change\r\n     * the content of the value. */\n\n\n    _this.value = value;\n    return _this;\n  }\n  /** @override */\n\n\n  Constant.prototype.decode = function (b, offset) {\n    return this.value;\n  };\n  /** @override */\n\n\n  Constant.prototype.encode = function (src, b, offset) {\n    /* Constants take no space */\n    return 0;\n  };\n\n  return Constant;\n}(Layout);\n\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */\n\nexports.greedy = function (elementSpan, property) {\n  return new GreedyCount(elementSpan, property);\n};\n/** Factory for {@link OffsetLayout}. */\n\n\nexports.offset = function (layout, offset, property) {\n  return new OffsetLayout(layout, offset, property);\n};\n/** Factory for {@link UInt|unsigned int layouts} spanning one\r\n * byte. */\n\n\nexports.u8 = function (property) {\n  return new UInt(1, property);\n};\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning two bytes. */\n\n\nexports.u16 = function (property) {\n  return new UInt(2, property);\n};\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning three bytes. */\n\n\nexports.u24 = function (property) {\n  return new UInt(3, property);\n};\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning four bytes. */\n\n\nexports.u32 = function (property) {\n  return new UInt(4, property);\n};\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning five bytes. */\n\n\nexports.u40 = function (property) {\n  return new UInt(5, property);\n};\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning six bytes. */\n\n\nexports.u48 = function (property) {\n  return new UInt(6, property);\n};\n/** Factory for {@link NearUInt64|little-endian unsigned int\r\n * layouts} interpreted as Numbers. */\n\n\nexports.nu64 = function (property) {\n  return new NearUInt64(property);\n};\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning two bytes. */\n\n\nexports.u16be = function (property) {\n  return new UIntBE(2, property);\n};\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning three bytes. */\n\n\nexports.u24be = function (property) {\n  return new UIntBE(3, property);\n};\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning four bytes. */\n\n\nexports.u32be = function (property) {\n  return new UIntBE(4, property);\n};\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning five bytes. */\n\n\nexports.u40be = function (property) {\n  return new UIntBE(5, property);\n};\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning six bytes. */\n\n\nexports.u48be = function (property) {\n  return new UIntBE(6, property);\n};\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\r\n * layouts} interpreted as Numbers. */\n\n\nexports.nu64be = function (property) {\n  return new NearUInt64BE(property);\n};\n/** Factory for {@link Int|signed int layouts} spanning one\r\n * byte. */\n\n\nexports.s8 = function (property) {\n  return new Int(1, property);\n};\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning two bytes. */\n\n\nexports.s16 = function (property) {\n  return new Int(2, property);\n};\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning three bytes. */\n\n\nexports.s24 = function (property) {\n  return new Int(3, property);\n};\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning four bytes. */\n\n\nexports.s32 = function (property) {\n  return new Int(4, property);\n};\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning five bytes. */\n\n\nexports.s40 = function (property) {\n  return new Int(5, property);\n};\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning six bytes. */\n\n\nexports.s48 = function (property) {\n  return new Int(6, property);\n};\n/** Factory for {@link NearInt64|little-endian signed int layouts}\r\n * interpreted as Numbers. */\n\n\nexports.ns64 = function (property) {\n  return new NearInt64(property);\n};\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning two bytes. */\n\n\nexports.s16be = function (property) {\n  return new IntBE(2, property);\n};\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning three bytes. */\n\n\nexports.s24be = function (property) {\n  return new IntBE(3, property);\n};\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning four bytes. */\n\n\nexports.s32be = function (property) {\n  return new IntBE(4, property);\n};\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning five bytes. */\n\n\nexports.s40be = function (property) {\n  return new IntBE(5, property);\n};\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning six bytes. */\n\n\nexports.s48be = function (property) {\n  return new IntBE(6, property);\n};\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\r\n * interpreted as Numbers. */\n\n\nexports.ns64be = function (property) {\n  return new NearInt64BE(property);\n};\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\n\n\nexports.f32 = function (property) {\n  return new Float(property);\n};\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\n\n\nexports.f32be = function (property) {\n  return new FloatBE(property);\n};\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\n\n\nexports.f64 = function (property) {\n  return new Double(property);\n};\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\n\n\nexports.f64be = function (property) {\n  return new DoubleBE(property);\n};\n/** Factory for {@link Structure} values. */\n\n\nexports.struct = function (fields, property, decodePrefixes) {\n  return new Structure(fields, property, decodePrefixes);\n};\n/** Factory for {@link BitStructure} values. */\n\n\nexports.bits = function (word, msb, property) {\n  return new BitStructure(word, msb, property);\n};\n/** Factory for {@link Sequence} values. */\n\n\nexports.seq = function (elementLayout, count, property) {\n  return new Sequence(elementLayout, count, property);\n};\n/** Factory for {@link Union} values. */\n\n\nexports.union = function (discr, defaultLayout, property) {\n  return new Union(discr, defaultLayout, property);\n};\n/** Factory for {@link UnionLayoutDiscriminator} values. */\n\n\nexports.unionLayoutDiscriminator = function (layout, property) {\n  return new UnionLayoutDiscriminator(layout, property);\n};\n/** Factory for {@link Blob} values. */\n\n\nexports.blob = function (length, property) {\n  return new Blob(length, property);\n};\n/** Factory for {@link CString} values. */\n\n\nexports.cstr = function (property) {\n  return new CString(property);\n};\n/** Factory for {@link UTF8} values. */\n\n\nexports.utf8 = function (maxSpan, property) {\n  return new UTF8(maxSpan, property);\n};\n/** Factory for {@link Constant} values. */\n\n\nexports.constant = function (value, property) {\n  return new Constant(value, property);\n};","map":{"version":3,"sources":["../src/Layout.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* The MIT License (MIT)\r\n *\r\n * Copyright 2015-2018 Peter A. Bigot\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n/**\r\n * Support for translating between Uint8Array instances and JavaScript\r\n * native types.\r\n *\r\n * {@link module:Layout~Layout|Layout} is the basis of a class\r\n * hierarchy that associates property names with sequences of encoded\r\n * bytes.\r\n *\r\n * Layouts are supported for these scalar (numeric) types:\r\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\r\n *   format} with {@link module:Layout.u8|8-bit}, {@link\r\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\r\n *   {@link module:Layout.u32|32-bit}, {@link\r\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\r\n *   representation ranges;\r\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\r\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\r\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\r\n *   {@link module:Layout.u40be|40-bit}, and {@link\r\n *   module:Layout.u48be|48-bit} representation ranges;\r\n * * {@link module:Layout~Int|Signed integers in little-endian\r\n *   format} with {@link module:Layout.s8|8-bit}, {@link\r\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\r\n *   {@link module:Layout.s32|32-bit}, {@link\r\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\r\n *   representation ranges;\r\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\r\n *   with {@link module:Layout.s16be|16-bit}, {@link\r\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\r\n *   {@link module:Layout.s40be|40-bit}, and {@link\r\n *   module:Layout.s48be|48-bit} representation ranges;\r\n * * 64-bit integral values that decode to an exact (if magnitude is\r\n *   less than 2^53) or nearby integral Number in {@link\r\n *   module:Layout.nu64|unsigned little-endian}, {@link\r\n *   module:Layout.nu64be|unsigned big-endian}, {@link\r\n *   module:Layout.ns64|signed little-endian}, and {@link\r\n *   module:Layout.ns64be|unsigned big-endian} encodings;\r\n * * 32-bit floating point values with {@link\r\n *   module:Layout.f32|little-endian} and {@link\r\n *   module:Layout.f32be|big-endian} representations;\r\n * * 64-bit floating point values with {@link\r\n *   module:Layout.f64|little-endian} and {@link\r\n *   module:Layout.f64be|big-endian} representations;\r\n * * {@link module:Layout.const|Constants} that take no space in the\r\n *   encoded expression.\r\n *\r\n * and for these aggregate types:\r\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\r\n *   module:Layout~Layout|Layout}, with JavaScript representation as\r\n *   an Array and constant or data-dependent {@link\r\n *   module:Layout~Sequence#count|length};\r\n * * {@link module:Layout.struct|Structure}s that aggregate a\r\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\r\n *   instances, with JavaScript representation as an Object;\r\n * * {@link module:Layout.union|Union}s that support multiple {@link\r\n *   module:Layout~VariantLayout|variant layouts} over a fixed\r\n *   (padded) or variable (not padded) span of bytes, using an\r\n *   unsigned integer at the start of the data or a separate {@link\r\n *   module:Layout.unionLayoutDiscriminator|layout element} to\r\n *   determine which layout to use when interpreting the buffer\r\n *   contents;\r\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\r\n *   of individual {@link\r\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\r\n *   16, 24, or 32-bit unsigned integer starting at the least- or\r\n *   most-significant bit;\r\n * * {@link module:Layout.cstr|C strings} of varying length;\r\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\r\n *   module:Layout~Blob#length|length} raw data.\r\n *\r\n * All {@link module:Layout~Layout|Layout} instances are immutable\r\n * after construction, to prevent internal state from becoming\r\n * inconsistent.\r\n *\r\n * @local Layout\r\n * @local ExternalLayout\r\n * @local GreedyCount\r\n * @local OffsetLayout\r\n * @local UInt\r\n * @local UIntBE\r\n * @local Int\r\n * @local IntBE\r\n * @local NearUInt64\r\n * @local NearUInt64BE\r\n * @local NearInt64\r\n * @local NearInt64BE\r\n * @local Float\r\n * @local FloatBE\r\n * @local Double\r\n * @local DoubleBE\r\n * @local Sequence\r\n * @local Structure\r\n * @local UnionDiscriminator\r\n * @local UnionLayoutDiscriminator\r\n * @local Union\r\n * @local VariantLayout\r\n * @local BitStructure\r\n * @local BitField\r\n * @local Boolean\r\n * @local Blob\r\n * @local CString\r\n * @local Constant\r\n * @local bindConstructorLayout\r\n * @module Layout\r\n * @license MIT\r\n * @author Peter A. Bigot\r\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\r\n */\r\n'use strict';\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\r\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\r\nvar buffer_1 = require(\"buffer\");\r\n/* Check if a value is a Uint8Array.\r\n *\r\n * @ignore */\r\nfunction checkUint8Array(b) {\r\n    if (!(b instanceof Uint8Array)) {\r\n        throw new TypeError('b must be a Uint8Array');\r\n    }\r\n}\r\nexports.checkUint8Array = checkUint8Array;\r\n/* Create a Buffer instance from a Uint8Array.\r\n *\r\n * @ignore */\r\nfunction uint8ArrayToBuffer(b) {\r\n    checkUint8Array(b);\r\n    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\r\n}\r\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\r\n/**\r\n * Base class for layout objects.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support the {@link\r\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\r\n *\r\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\r\n * parameter must be an integer; a negative value signifies that the\r\n * span is {@link Layout#getSpan|value-specific}.\r\n *\r\n * @param {string} [property] - Initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @abstract\r\n */\r\nvar Layout = /** @class */ (function () {\r\n    function Layout(span, property) {\r\n        if (!Number.isInteger(span)) {\r\n            throw new TypeError('span must be an integer');\r\n        }\r\n        /** The span of the layout in bytes.\r\n         *\r\n         * Positive values are generally expected.\r\n         *\r\n         * Zero will only appear in {@link Constant}s and in {@link\r\n         * Sequence}s where the {@link Sequence#count|count} is zero.\r\n         *\r\n         * A negative value indicates that the span is value-specific, and\r\n         * must be obtained using {@link Layout#getSpan|getSpan}. */\r\n        this.span = span;\r\n        /** The property name used when this layout is represented in an\r\n         * Object.\r\n         *\r\n         * Used only for layouts that {@link Layout#decode|decode} to Object\r\n         * instances.  If left undefined the span of the unnamed layout will\r\n         * be treated as padding: it will not be mutated by {@link\r\n         * Layout#encode|encode} nor represented as a property in the\r\n         * decoded Object. */\r\n        this.property = property;\r\n    }\r\n    /** Function to create an Object into which decoded properties will\r\n     * be written.\r\n     *\r\n     * Used only for layouts that {@link Layout#decode|decode} to Object\r\n     * instances, which means:\r\n     * * {@link Structure}\r\n     * * {@link Union}\r\n     * * {@link VariantLayout}\r\n     * * {@link BitStructure}\r\n     *\r\n     * If left undefined the JavaScript representation of these layouts\r\n     * will be Object instances.\r\n     *\r\n     * See {@link bindConstructorLayout}.\r\n     */\r\n    Layout.prototype.makeDestinationObject = function () {\r\n        return {};\r\n    };\r\n    /**\r\n     * Decode from a Uint8Array into a JavaScript value.\r\n     *\r\n     * @param {Uint8Array} b - the buffer from which encoded data is read.\r\n     *\r\n     * @param {Number} [offset] - the offset at which the encoded data\r\n     * starts.  If absent a zero offset is inferred.\r\n     *\r\n     * @returns {(Number|Array|Object)} - the value of the decoded data.\r\n     *\r\n     * @abstract\r\n     */\r\n    Layout.prototype.decode = function (b, offset) {\r\n        throw new Error('Layout is abstract');\r\n    };\r\n    /**\r\n     * Encode a JavaScript value into a Uint8Array.\r\n     *\r\n     * @param {(Number|Array|Object)} src - the value to be encoded into\r\n     * the buffer.  The type accepted depends on the (sub-)type of {@link\r\n     * Layout}.\r\n     *\r\n     * @param {Uint8Array} b - the buffer into which encoded data will be\r\n     * written.\r\n     *\r\n     * @param {Number} [offset] - the offset at which the encoded data\r\n     * starts.  If absent a zero offset is inferred.\r\n     *\r\n     * @returns {Number} - the number of bytes encoded, including the\r\n     * space skipped for internal padding, but excluding data such as\r\n     * {@link Sequence#count|lengths} when stored {@link\r\n     * ExternalLayout|externally}.  This is the adjustment to `offset`\r\n     * producing the offset where data for the next layout would be\r\n     * written.\r\n     *\r\n     * @abstract\r\n     */\r\n    Layout.prototype.encode = function (src, b, offset) {\r\n        throw new Error('Layout is abstract');\r\n    };\r\n    /**\r\n     * Calculate the span of a specific instance of a layout.\r\n     *\r\n     * @param {Uint8Array} b - the buffer that contains an encoded instance.\r\n     *\r\n     * @param {Number} [offset] - the offset at which the encoded instance\r\n     * starts.  If absent a zero offset is inferred.\r\n     *\r\n     * @return {Number} - the number of bytes covered by the layout\r\n     * instance.  If this method is not overridden in a subclass the\r\n     * definition-time constant {@link Layout#span|span} will be\r\n     * returned.\r\n     *\r\n     * @throws {RangeError} - if the length of the value cannot be\r\n     * determined.\r\n     */\r\n    Layout.prototype.getSpan = function (b, offset) {\r\n        if (0 > this.span) {\r\n            throw new RangeError('indeterminate span');\r\n        }\r\n        return this.span;\r\n    };\r\n    /**\r\n     * Replicate the layout using a new property.\r\n     *\r\n     * This function must be used to get a structurally-equivalent layout\r\n     * with a different name since all {@link Layout} instances are\r\n     * immutable.\r\n     *\r\n     * **NOTE** This is a shallow copy.  All fields except {@link\r\n     * Layout#property|property} are strictly equal to the origin layout.\r\n     *\r\n     * @param {String} property - the value for {@link\r\n     * Layout#property|property} in the replica.\r\n     *\r\n     * @returns {Layout} - the copy with {@link Layout#property|property}\r\n     * set to `property`.\r\n     */\r\n    Layout.prototype.replicate = function (property) {\r\n        var rv = Object.create(this.constructor.prototype);\r\n        Object.assign(rv, this);\r\n        rv.property = property;\r\n        return rv;\r\n    };\r\n    /**\r\n     * Create an object from layout properties and an array of values.\r\n     *\r\n     * **NOTE** This function returns `undefined` if invoked on a layout\r\n     * that does not return its value as an Object.  Objects are\r\n     * returned for things that are a {@link Structure}, which includes\r\n     * {@link VariantLayout|variant layouts} if they are structures, and\r\n     * excludes {@link Union}s.  If you want this feature for a union\r\n     * you must use {@link Union.getVariant|getVariant} to select the\r\n     * desired layout.\r\n     *\r\n     * @param {Array} values - an array of values that correspond to the\r\n     * default order for properties.  As with {@link Layout#decode|decode}\r\n     * layout elements that have no property name are skipped when\r\n     * iterating over the array values.  Only the top-level properties are\r\n     * assigned; arguments are not assigned to properties of contained\r\n     * layouts.  Any unused values are ignored.\r\n     *\r\n     * @return {(Object|undefined)}\r\n     */\r\n    Layout.prototype.fromArray = function (values) {\r\n        return undefined;\r\n    };\r\n    return Layout;\r\n}());\r\nexports.Layout = Layout;\r\n/* Provide text that carries a name (such as for a function that will\r\n * be throwing an error) annotated with the property of a given layout\r\n * (such as one for which the value was unacceptable).\r\n *\r\n * @ignore */\r\nfunction nameWithProperty(name, lo) {\r\n    if (lo.property) {\r\n        return name + '[' + lo.property + ']';\r\n    }\r\n    return name;\r\n}\r\nexports.nameWithProperty = nameWithProperty;\r\n/**\r\n * Augment a class so that instances can be encoded/decoded using a\r\n * given layout.\r\n *\r\n * Calling this function couples `Class` with `layout` in several ways:\r\n *\r\n * * `Class.layout_` becomes a static member property equal to `layout`;\r\n * * `layout.boundConstructor_` becomes a static member property equal\r\n *    to `Class`;\r\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\r\n *   property of `layout` is set to a function that returns a `new\r\n *   Class()`;\r\n * * `Class.decode(b, offset)` becomes a static member function that\r\n *   delegates to {@link Layout#decode|layout.decode}.  The\r\n *   synthesized function may be captured and extended.\r\n * * `Class.prototype.encode(b, offset)` provides an instance member\r\n *   function that delegates to {@link Layout#encode|layout.encode}\r\n *   with `src` set to `this`.  The synthesized function may be\r\n *   captured and extended, but when the extension is invoked `this`\r\n *   must be explicitly bound to the instance.\r\n *\r\n * @param {class} Class - a JavaScript class with a nullary\r\n * constructor.\r\n *\r\n * @param {Layout} layout - the {@link Layout} instance used to encode\r\n * instances of `Class`.\r\n */\r\nfunction bindConstructorLayout(Class, layout) {\r\n    if ('function' !== typeof Class) {\r\n        throw new TypeError('Class must be constructor');\r\n    }\r\n    if (Object.prototype.hasOwnProperty.call(Class, 'layout_')) {\r\n        throw new Error('Class is already bound to a layout');\r\n    }\r\n    if (!(layout && (layout instanceof Layout))) {\r\n        throw new TypeError('layout must be a Layout');\r\n    }\r\n    if (Object.prototype.hasOwnProperty.call(layout, 'boundConstructor_')) {\r\n        throw new Error('layout is already bound to a constructor');\r\n    }\r\n    Class.layout_ = layout;\r\n    layout.boundConstructor_ = Class;\r\n    layout.makeDestinationObject = (function () { return new Class(); });\r\n    Object.defineProperty(Class.prototype, 'encode', {\r\n        value: function (b, offset) {\r\n            return layout.encode(this, b, offset);\r\n        },\r\n        writable: true\r\n    });\r\n    Object.defineProperty(Class, 'decode', {\r\n        value: function (b, offset) {\r\n            return layout.decode(b, offset);\r\n        },\r\n        writable: true\r\n    });\r\n}\r\nexports.bindConstructorLayout = bindConstructorLayout;\r\n/**\r\n * An object that behaves like a layout but does not consume space\r\n * within its containing layout.\r\n *\r\n * This is primarily used to obtain metadata about a member, such as a\r\n * {@link OffsetLayout} that can provide data about a {@link\r\n * Layout#getSpan|value-specific span}.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support {@link\r\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @abstract\r\n * @augments {Layout}\r\n */\r\nvar ExternalLayout = /** @class */ (function (_super) {\r\n    __extends(ExternalLayout, _super);\r\n    function ExternalLayout() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Return `true` iff the external layout decodes to an unsigned\r\n     * integer layout.\r\n     *\r\n     * In that case it can be used as the source of {@link\r\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\r\n     * or as {@link UnionLayoutDiscriminator#layout|external union\r\n     * discriminators}.\r\n     *\r\n     * @abstract\r\n     */\r\n    ExternalLayout.prototype.isCount = function () {\r\n        throw new Error('ExternalLayout is abstract');\r\n    };\r\n    return ExternalLayout;\r\n}(Layout));\r\nexports.ExternalLayout = ExternalLayout;\r\n/**\r\n * An {@link ExternalLayout} that determines its {@link\r\n * Layout#decode|value} based on offset into and length of the buffer\r\n * on which it is invoked.\r\n *\r\n * *Factory*: {@link module:Layout.greedy|greedy}\r\n *\r\n * @param {Number} [elementSpan] - initializer for {@link\r\n * GreedyCount#elementSpan|elementSpan}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {ExternalLayout}\r\n */\r\nvar GreedyCount = /** @class */ (function (_super) {\r\n    __extends(GreedyCount, _super);\r\n    function GreedyCount(elementSpan, property) {\r\n        var _this = this;\r\n        if (undefined === elementSpan) {\r\n            elementSpan = 1;\r\n        }\r\n        if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {\r\n            throw new TypeError('elementSpan must be a (positive) integer');\r\n        }\r\n        _this = _super.call(this, -1, property) || this;\r\n        /** The layout for individual elements of the sequence.  The value\r\n         * must be a positive integer.  If not provided, the value will be\r\n         * 1. */\r\n        _this.elementSpan = elementSpan;\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    GreedyCount.prototype.isCount = function () {\r\n        return true;\r\n    };\r\n    /** @override */\r\n    GreedyCount.prototype.decode = function (b, offset) {\r\n        checkUint8Array(b);\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var rem = b.length - offset;\r\n        return Math.floor(rem / this.elementSpan);\r\n    };\r\n    /** @override */\r\n    GreedyCount.prototype.encode = function (src, b, offset) {\r\n        return 0;\r\n    };\r\n    return GreedyCount;\r\n}(ExternalLayout));\r\nexports.GreedyCount = GreedyCount;\r\n/**\r\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\r\n * at a fixed offset from the start of another Layout.  The offset may\r\n * be before, within, or after the base layout.\r\n *\r\n * *Factory*: {@link module:Layout.offset|offset}\r\n *\r\n * @param {Layout} layout - initializer for {@link\r\n * OffsetLayout#layout|layout}, modulo `property`.\r\n *\r\n * @param {Number} [offset] - Initializes {@link\r\n * OffsetLayout#offset|offset}.  Defaults to zero.\r\n *\r\n * @param {string} [property] - Optional new property name for a\r\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\r\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\r\n * unchanged.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar OffsetLayout = /** @class */ (function (_super) {\r\n    __extends(OffsetLayout, _super);\r\n    function OffsetLayout(layout, offset, property) {\r\n        var _this = this;\r\n        if (!(layout instanceof Layout)) {\r\n            throw new TypeError('layout must be a Layout');\r\n        }\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        else if (!Number.isInteger(offset)) {\r\n            throw new TypeError('offset must be integer or undefined');\r\n        }\r\n        _this = _super.call(this, layout.span, property || layout.property) || this;\r\n        /** The subordinated layout. */\r\n        _this.layout = layout;\r\n        /** The location of {@link OffsetLayout#layout} relative to the\r\n         * start of another layout.\r\n         *\r\n         * The value may be positive or negative, but an error will thrown\r\n         * if at the point of use it goes outside the span of the Uint8Array\r\n         * being accessed.  */\r\n        _this.offset = offset;\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    OffsetLayout.prototype.isCount = function () {\r\n        return ((this.layout instanceof UInt)\r\n            || (this.layout instanceof UIntBE));\r\n    };\r\n    /** @override */\r\n    OffsetLayout.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        return this.layout.decode(b, offset + this.offset);\r\n    };\r\n    /** @override */\r\n    OffsetLayout.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        return this.layout.encode(src, b, offset + this.offset);\r\n    };\r\n    return OffsetLayout;\r\n}(ExternalLayout));\r\nexports.OffsetLayout = OffsetLayout;\r\n/**\r\n * Represent an unsigned integer in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.u8|u8}, {@link\r\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\r\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\r\n *  module:Layout.u48|u48}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar UInt = /** @class */ (function (_super) {\r\n    __extends(UInt, _super);\r\n    function UInt(span, property) {\r\n        var _this = _super.call(this, span, property) || this;\r\n        if (6 < _this.span) {\r\n            throw new RangeError('span must not exceed 6 bytes');\r\n        }\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    UInt.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\r\n    };\r\n    /** @override */\r\n    UInt.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\r\n        return this.span;\r\n    };\r\n    return UInt;\r\n}(Layout));\r\nexports.UInt = UInt;\r\n/**\r\n * Represent an unsigned integer in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\r\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\r\n * {@link module:Layout.u32be|u32be}, {@link\r\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar UIntBE = /** @class */ (function (_super) {\r\n    __extends(UIntBE, _super);\r\n    function UIntBE(span, property) {\r\n        var _this = _super.call(this, span, property) || this;\r\n        if (6 < _this.span) {\r\n            throw new RangeError('span must not exceed 6 bytes');\r\n        }\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    UIntBE.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\r\n    };\r\n    /** @override */\r\n    UIntBE.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\r\n        return this.span;\r\n    };\r\n    return UIntBE;\r\n}(Layout));\r\nexports.UIntBE = UIntBE;\r\n/**\r\n * Represent a signed integer in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.s8|s8}, {@link\r\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\r\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\r\n *  module:Layout.s48|s48}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar Int = /** @class */ (function (_super) {\r\n    __extends(Int, _super);\r\n    function Int(span, property) {\r\n        var _this = _super.call(this, span, property) || this;\r\n        if (6 < _this.span) {\r\n            throw new RangeError('span must not exceed 6 bytes');\r\n        }\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    Int.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\r\n    };\r\n    /** @override */\r\n    Int.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\r\n        return this.span;\r\n    };\r\n    return Int;\r\n}(Layout));\r\nexports.Int = Int;\r\n/**\r\n * Represent a signed integer in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\r\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\r\n * {@link module:Layout.s32be|s32be}, {@link\r\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar IntBE = /** @class */ (function (_super) {\r\n    __extends(IntBE, _super);\r\n    function IntBE(span, property) {\r\n        var _this = _super.call(this, span, property) || this;\r\n        if (6 < _this.span) {\r\n            throw new RangeError('span must not exceed 6 bytes');\r\n        }\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    IntBE.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\r\n    };\r\n    /** @override */\r\n    IntBE.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\r\n        return this.span;\r\n    };\r\n    return IntBE;\r\n}(Layout));\r\nexports.IntBE = IntBE;\r\nvar V2E32 = Math.pow(2, 32);\r\n/* True modulus high and low 32-bit words, where low word is always\r\n * non-negative. */\r\nfunction divmodInt64(src) {\r\n    var hi32 = Math.floor(src / V2E32);\r\n    var lo32 = src - (hi32 * V2E32);\r\n    return { hi32: hi32, lo32: lo32 };\r\n}\r\n/* Reconstruct Number from quotient and non-negative remainder */\r\nfunction roundedInt64(hi32, lo32) {\r\n    return hi32 * V2E32 + lo32;\r\n}\r\n/**\r\n * Represent an unsigned 64-bit integer in little-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.nu64|nu64}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar NearUInt64 = /** @class */ (function (_super) {\r\n    __extends(NearUInt64, _super);\r\n    function NearUInt64(property) {\r\n        return _super.call(this, 8, property) || this;\r\n    }\r\n    /** @override */\r\n    NearUInt64.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var buffer = uint8ArrayToBuffer(b);\r\n        var lo32 = buffer.readUInt32LE(offset);\r\n        var hi32 = buffer.readUInt32LE(offset + 4);\r\n        return roundedInt64(hi32, lo32);\r\n    };\r\n    /** @override */\r\n    NearUInt64.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var split = divmodInt64(src);\r\n        var buffer = uint8ArrayToBuffer(b);\r\n        buffer.writeUInt32LE(split.lo32, offset);\r\n        buffer.writeUInt32LE(split.hi32, offset + 4);\r\n        return 8;\r\n    };\r\n    return NearUInt64;\r\n}(Layout));\r\nexports.NearUInt64 = NearUInt64;\r\n/**\r\n * Represent an unsigned 64-bit integer in big-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.nu64be|nu64be}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar NearUInt64BE = /** @class */ (function (_super) {\r\n    __extends(NearUInt64BE, _super);\r\n    function NearUInt64BE(property) {\r\n        return _super.call(this, 8, property) || this;\r\n    }\r\n    /** @override */\r\n    NearUInt64BE.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var buffer = uint8ArrayToBuffer(b);\r\n        var hi32 = buffer.readUInt32BE(offset);\r\n        var lo32 = buffer.readUInt32BE(offset + 4);\r\n        return roundedInt64(hi32, lo32);\r\n    };\r\n    /** @override */\r\n    NearUInt64BE.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var split = divmodInt64(src);\r\n        var buffer = uint8ArrayToBuffer(b);\r\n        buffer.writeUInt32BE(split.hi32, offset);\r\n        buffer.writeUInt32BE(split.lo32, offset + 4);\r\n        return 8;\r\n    };\r\n    return NearUInt64BE;\r\n}(Layout));\r\nexports.NearUInt64BE = NearUInt64BE;\r\n/**\r\n * Represent a signed 64-bit integer in little-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.ns64|ns64}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar NearInt64 = /** @class */ (function (_super) {\r\n    __extends(NearInt64, _super);\r\n    function NearInt64(property) {\r\n        return _super.call(this, 8, property) || this;\r\n    }\r\n    /** @override */\r\n    NearInt64.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var buffer = uint8ArrayToBuffer(b);\r\n        var lo32 = buffer.readUInt32LE(offset);\r\n        var hi32 = buffer.readInt32LE(offset + 4);\r\n        return roundedInt64(hi32, lo32);\r\n    };\r\n    /** @override */\r\n    NearInt64.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var split = divmodInt64(src);\r\n        var buffer = uint8ArrayToBuffer(b);\r\n        buffer.writeUInt32LE(split.lo32, offset);\r\n        buffer.writeInt32LE(split.hi32, offset + 4);\r\n        return 8;\r\n    };\r\n    return NearInt64;\r\n}(Layout));\r\nexports.NearInt64 = NearInt64;\r\n/**\r\n * Represent a signed 64-bit integer in big-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.ns64be|ns64be}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar NearInt64BE = /** @class */ (function (_super) {\r\n    __extends(NearInt64BE, _super);\r\n    function NearInt64BE(property) {\r\n        return _super.call(this, 8, property) || this;\r\n    }\r\n    /** @override */\r\n    NearInt64BE.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var buffer = uint8ArrayToBuffer(b);\r\n        var hi32 = buffer.readInt32BE(offset);\r\n        var lo32 = buffer.readUInt32BE(offset + 4);\r\n        return roundedInt64(hi32, lo32);\r\n    };\r\n    /** @override */\r\n    NearInt64BE.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var split = divmodInt64(src);\r\n        var buffer = uint8ArrayToBuffer(b);\r\n        buffer.writeInt32BE(split.hi32, offset);\r\n        buffer.writeUInt32BE(split.lo32, offset + 4);\r\n        return 8;\r\n    };\r\n    return NearInt64BE;\r\n}(Layout));\r\nexports.NearInt64BE = NearInt64BE;\r\n/**\r\n * Represent a 32-bit floating point number in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f32|f32}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar Float = /** @class */ (function (_super) {\r\n    __extends(Float, _super);\r\n    function Float(property) {\r\n        return _super.call(this, 4, property) || this;\r\n    }\r\n    /** @override */\r\n    Float.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        return uint8ArrayToBuffer(b).readFloatLE(offset);\r\n    };\r\n    /** @override */\r\n    Float.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        uint8ArrayToBuffer(b).writeFloatLE(src, offset);\r\n        return 4;\r\n    };\r\n    return Float;\r\n}(Layout));\r\nexports.Float = Float;\r\n/**\r\n * Represent a 32-bit floating point number in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f32be|f32be}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar FloatBE = /** @class */ (function (_super) {\r\n    __extends(FloatBE, _super);\r\n    function FloatBE(property) {\r\n        return _super.call(this, 4, property) || this;\r\n    }\r\n    /** @override */\r\n    FloatBE.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        return uint8ArrayToBuffer(b).readFloatBE(offset);\r\n    };\r\n    /** @override */\r\n    FloatBE.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        uint8ArrayToBuffer(b).writeFloatBE(src, offset);\r\n        return 4;\r\n    };\r\n    return FloatBE;\r\n}(Layout));\r\nexports.FloatBE = FloatBE;\r\n/**\r\n * Represent a 64-bit floating point number in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f64|f64}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar Double = /** @class */ (function (_super) {\r\n    __extends(Double, _super);\r\n    function Double(property) {\r\n        return _super.call(this, 8, property) || this;\r\n    }\r\n    /** @override */\r\n    Double.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        return uint8ArrayToBuffer(b).readDoubleLE(offset);\r\n    };\r\n    /** @override */\r\n    Double.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\r\n        return 8;\r\n    };\r\n    return Double;\r\n}(Layout));\r\nexports.Double = Double;\r\n/**\r\n * Represent a 64-bit floating point number in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f64be|f64be}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar DoubleBE = /** @class */ (function (_super) {\r\n    __extends(DoubleBE, _super);\r\n    function DoubleBE(property) {\r\n        return _super.call(this, 8, property) || this;\r\n    }\r\n    /** @override */\r\n    DoubleBE.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        return uint8ArrayToBuffer(b).readDoubleBE(offset);\r\n    };\r\n    /** @override */\r\n    DoubleBE.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\r\n        return 8;\r\n    };\r\n    return DoubleBE;\r\n}(Layout));\r\nexports.DoubleBE = DoubleBE;\r\n/**\r\n * Represent a contiguous sequence of a specific layout as an Array.\r\n *\r\n * *Factory*: {@link module:Layout.seq|seq}\r\n *\r\n * @param {Layout} elementLayout - initializer for {@link\r\n * Sequence#elementLayout|elementLayout}.\r\n *\r\n * @param {(Number|ExternalLayout)} count - initializer for {@link\r\n * Sequence#count|count}.  The parameter must be either a positive\r\n * integer or an instance of {@link ExternalLayout}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar Sequence = /** @class */ (function (_super) {\r\n    __extends(Sequence, _super);\r\n    function Sequence(elementLayout, count, property) {\r\n        var _this = this;\r\n        if (!(elementLayout instanceof Layout)) {\r\n            throw new TypeError('elementLayout must be a Layout');\r\n        }\r\n        if (!(((count instanceof ExternalLayout) && count.isCount())\r\n            || (Number.isInteger(count) && (0 <= count)))) {\r\n            throw new TypeError('count must be non-negative integer '\r\n                + 'or an unsigned integer ExternalLayout');\r\n        }\r\n        var span = -1;\r\n        if ((!(count instanceof ExternalLayout))\r\n            && (0 < elementLayout.span)) {\r\n            span = count * elementLayout.span;\r\n        }\r\n        _this = _super.call(this, span, property) || this;\r\n        /** The layout for individual elements of the sequence. */\r\n        _this.elementLayout = elementLayout;\r\n        /** The number of elements in the sequence.\r\n         *\r\n         * This will be either a non-negative integer or an instance of\r\n         * {@link ExternalLayout} for which {@link\r\n         * ExternalLayout#isCount|isCount()} is `true`. */\r\n        _this.count = count;\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    Sequence.prototype.getSpan = function (b, offset) {\r\n        if (0 <= this.span) {\r\n            return this.span;\r\n        }\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var span = 0;\r\n        var count = this.count;\r\n        if (count instanceof ExternalLayout) {\r\n            count = count.decode(b, offset);\r\n        }\r\n        if (0 < this.elementLayout.span) {\r\n            span = count * this.elementLayout.span;\r\n        }\r\n        else {\r\n            var idx = 0;\r\n            while (idx < count) {\r\n                span += this.elementLayout.getSpan(b, offset + span);\r\n                ++idx;\r\n            }\r\n        }\r\n        return span;\r\n    };\r\n    /** @override */\r\n    Sequence.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var rv = [];\r\n        var i = 0;\r\n        var count = this.count;\r\n        if (count instanceof ExternalLayout) {\r\n            count = count.decode(b, offset);\r\n        }\r\n        while (i < count) {\r\n            rv.push(this.elementLayout.decode(b, offset));\r\n            offset += this.elementLayout.getSpan(b, offset);\r\n            i += 1;\r\n        }\r\n        return rv;\r\n    };\r\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\r\n     *\r\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\r\n     * the unused space in the buffer is left unchanged.  If `src` is\r\n     * longer than {@link Sequence#count|count} the unneeded elements are\r\n     * ignored.\r\n     *\r\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\r\n     * ExternalLayout} then the length of `src` will be encoded as the\r\n     * count after `src` is encoded. */\r\n    Sequence.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var elo = this.elementLayout;\r\n        var span = src.reduce(function (span, v) {\r\n            return span + elo.encode(v, b, offset + span);\r\n        }, 0);\r\n        if (this.count instanceof ExternalLayout) {\r\n            this.count.encode(src.length, b, offset);\r\n        }\r\n        return span;\r\n    };\r\n    return Sequence;\r\n}(Layout));\r\nexports.Sequence = Sequence;\r\n/**\r\n * Represent a contiguous sequence of arbitrary layout elements as an\r\n * Object.\r\n *\r\n * *Factory*: {@link module:Layout.struct|struct}\r\n *\r\n * **NOTE** The {@link Layout#span|span} of the structure is variable\r\n * if any layout in {@link Structure#fields|fields} has a variable\r\n * span.  When {@link Layout#encode|encoding} we must have a value for\r\n * all variable-length fields, or we wouldn't be able to figure out\r\n * how much space to use for storage.  We can only identify the value\r\n * for a field when it has a {@link Layout#property|property}.  As\r\n * such, although a structure may contain both unnamed fields and\r\n * variable-length fields, it cannot contain an unnamed\r\n * variable-length field.\r\n *\r\n * @param {Layout[]} fields - initializer for {@link\r\n * Structure#fields|fields}.  An error is raised if this contains a\r\n * variable-length field for which a {@link Layout#property|property}\r\n * is not defined.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @param {Boolean} [decodePrefixes] - initializer for {@link\r\n * Structure#decodePrefixes|property}.\r\n *\r\n * @throws {Error} - if `fields` contains an unnamed variable-length\r\n * layout.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar Structure = /** @class */ (function (_super) {\r\n    __extends(Structure, _super);\r\n    function Structure(fields, property, decodePrefixes) {\r\n        var _this = this;\r\n        if (!(Array.isArray(fields)\r\n            && fields.reduce(function (acc, v) { return acc && (v instanceof Layout); }, true))) {\r\n            throw new TypeError('fields must be array of Layout instances');\r\n        }\r\n        if (('boolean' === typeof property)\r\n            && (undefined === decodePrefixes)) {\r\n            decodePrefixes = property;\r\n            property = undefined;\r\n        }\r\n        /* Verify absence of unnamed variable-length fields. */\r\n        for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {\r\n            var fd = fields_1[_i];\r\n            if ((0 > fd.span)\r\n                && (undefined === fd.property)) {\r\n                throw new Error('fields cannot contain unnamed variable-length layout');\r\n            }\r\n        }\r\n        var span = -1;\r\n        try {\r\n            span = fields.reduce(function (span, fd) { return span + fd.getSpan(); }, 0);\r\n        }\r\n        catch (e) {\r\n            // ignore error\r\n        }\r\n        _this = _super.call(this, span, property) || this;\r\n        /** The sequence of {@link Layout} values that comprise the\r\n         * structure.\r\n         *\r\n         * The individual elements need not be the same type, and may be\r\n         * either scalar or aggregate layouts.  If a member layout leaves\r\n         * its {@link Layout#property|property} undefined the\r\n         * corresponding region of the buffer associated with the element\r\n         * will not be mutated.\r\n         *\r\n         * @type {Layout[]} */\r\n        _this.fields = fields;\r\n        /** Control behavior of {@link Layout#decode|decode()} given short\r\n         * buffers.\r\n         *\r\n         * In some situations a structure many be extended with additional\r\n         * fields over time, with older installations providing only a\r\n         * prefix of the full structure.  If this property is `true`\r\n         * decoding will accept those buffers and leave subsequent fields\r\n         * undefined, as long as the buffer ends at a field boundary.\r\n         * Defaults to `false`. */\r\n        _this.decodePrefixes = !!decodePrefixes;\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    Structure.prototype.getSpan = function (b, offset) {\r\n        if (0 <= this.span) {\r\n            return this.span;\r\n        }\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var span = 0;\r\n        try {\r\n            span = this.fields.reduce(function (span, fd) {\r\n                var fsp = fd.getSpan(b, offset);\r\n                offset += fsp;\r\n                return span + fsp;\r\n            }, 0);\r\n        }\r\n        catch (e) {\r\n            throw new RangeError('indeterminate span');\r\n        }\r\n        return span;\r\n    };\r\n    /** @override */\r\n    Structure.prototype.decode = function (b, offset) {\r\n        checkUint8Array(b);\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var dest = this.makeDestinationObject();\r\n        for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\r\n            var fd = _a[_i];\r\n            if (undefined !== fd.property) {\r\n                dest[fd.property] = fd.decode(b, offset);\r\n            }\r\n            offset += fd.getSpan(b, offset);\r\n            if (this.decodePrefixes\r\n                && (b.length === offset)) {\r\n                break;\r\n            }\r\n        }\r\n        return dest;\r\n    };\r\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\r\n     *\r\n     * If `src` is missing a property for a member with a defined {@link\r\n     * Layout#property|property} the corresponding region of the buffer is\r\n     * left unmodified. */\r\n    Structure.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var firstOffset = offset;\r\n        var lastOffset = 0;\r\n        var lastWrote = 0;\r\n        for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\r\n            var fd = _a[_i];\r\n            var span = fd.span;\r\n            lastWrote = (0 < span) ? span : 0;\r\n            if (undefined !== fd.property) {\r\n                var fv = src[fd.property];\r\n                if (undefined !== fv) {\r\n                    lastWrote = fd.encode(fv, b, offset);\r\n                    if (0 > span) {\r\n                        /* Read the as-encoded span, which is not necessarily the\r\n                         * same as what we wrote. */\r\n                        span = fd.getSpan(b, offset);\r\n                    }\r\n                }\r\n            }\r\n            lastOffset = offset;\r\n            offset += span;\r\n        }\r\n        /* Use (lastOffset + lastWrote) instead of offset because the last\r\n         * item may have had a dynamic length and we don't want to include\r\n         * the padding between it and the end of the space reserved for\r\n         * it. */\r\n        return (lastOffset + lastWrote) - firstOffset;\r\n    };\r\n    /** @override */\r\n    Structure.prototype.fromArray = function (values) {\r\n        var dest = this.makeDestinationObject();\r\n        for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\r\n            var fd = _a[_i];\r\n            if ((undefined !== fd.property)\r\n                && (0 < values.length)) {\r\n                dest[fd.property] = values.shift();\r\n            }\r\n        }\r\n        return dest;\r\n    };\r\n    /**\r\n     * Get access to the layout of a given property.\r\n     *\r\n     * @param {String} property - the structure member of interest.\r\n     *\r\n     * @return {Layout} - the layout associated with `property`, or\r\n     * undefined if there is no such property.\r\n     */\r\n    Structure.prototype.layoutFor = function (property) {\r\n        if ('string' !== typeof property) {\r\n            throw new TypeError('property must be string');\r\n        }\r\n        for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\r\n            var fd = _a[_i];\r\n            if (fd.property === property) {\r\n                return fd;\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Get the offset of a structure member.\r\n     *\r\n     * @param {String} property - the structure member of interest.\r\n     *\r\n     * @return {Number} - the offset in bytes to the start of `property`\r\n     * within the structure, or undefined if `property` is not a field\r\n     * within the structure.  If the property is a member but follows a\r\n     * variable-length structure member a negative number will be\r\n     * returned.\r\n     */\r\n    Structure.prototype.offsetOf = function (property) {\r\n        if ('string' !== typeof property) {\r\n            throw new TypeError('property must be string');\r\n        }\r\n        var offset = 0;\r\n        for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\r\n            var fd = _a[_i];\r\n            if (fd.property === property) {\r\n                return offset;\r\n            }\r\n            if (0 > fd.span) {\r\n                offset = -1;\r\n            }\r\n            else if (0 <= offset) {\r\n                offset += fd.span;\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    return Structure;\r\n}(Layout));\r\nexports.Structure = Structure;\r\n/**\r\n * An object that can provide a {@link\r\n * Union#discriminator|discriminator} API for {@link Union}.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support the {@link\r\n * UnionDiscriminator#encode|encode} or {@link\r\n * UnionDiscriminator#decode|decode} functions.\r\n *\r\n * @param {string} [property] - Default for {@link\r\n * UnionDiscriminator#property|property}.\r\n *\r\n * @abstract\r\n */\r\nvar UnionDiscriminator = /** @class */ (function () {\r\n    function UnionDiscriminator(property) {\r\n        /** The {@link Layout#property|property} to be used when the\r\n         * discriminator is referenced in isolation (generally when {@link\r\n         * Union#decode|Union decode} cannot delegate to a specific\r\n         * variant). */\r\n        this.property = property;\r\n    }\r\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\r\n     *\r\n     * The implementation of this method need not reference the buffer if\r\n     * variant information is available through other means. */\r\n    UnionDiscriminator.prototype.decode = function (b, offset) {\r\n        throw new Error('UnionDiscriminator is abstract');\r\n    };\r\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\r\n     *\r\n     * The implementation of this method need not store the value if\r\n     * variant information is maintained through other means. */\r\n    UnionDiscriminator.prototype.encode = function (src, b, offset) {\r\n        throw new Error('UnionDiscriminator is abstract');\r\n    };\r\n    return UnionDiscriminator;\r\n}());\r\nexports.UnionDiscriminator = UnionDiscriminator;\r\n/**\r\n * An object that can provide a {@link\r\n * UnionDiscriminator|discriminator API} for {@link Union} using an\r\n * unsigned integral {@link Layout} instance located either inside or\r\n * outside the union.\r\n *\r\n * @param {ExternalLayout} layout - initializes {@link\r\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\r\n * ExternalLayout#isCount|isCount()}.\r\n *\r\n * @param {string} [property] - Default for {@link\r\n * UnionDiscriminator#property|property}, superseding the property\r\n * from `layout`, but defaulting to `variant` if neither `property`\r\n * nor layout provide a property name.\r\n *\r\n * @augments {UnionDiscriminator}\r\n */\r\nvar UnionLayoutDiscriminator = /** @class */ (function (_super) {\r\n    __extends(UnionLayoutDiscriminator, _super);\r\n    function UnionLayoutDiscriminator(layout, property) {\r\n        var _this = this;\r\n        if (!((layout instanceof ExternalLayout)\r\n            && layout.isCount())) {\r\n            throw new TypeError('layout must be an unsigned integer ExternalLayout');\r\n        }\r\n        _this = _super.call(this, property || layout.property || 'variant') || this;\r\n        /** The {@link ExternalLayout} used to access the discriminator\r\n         * value. */\r\n        _this.layout = layout;\r\n        return _this;\r\n    }\r\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\r\n    UnionLayoutDiscriminator.prototype.decode = function (b, offset) {\r\n        return this.layout.decode(b, offset);\r\n    };\r\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\r\n    UnionLayoutDiscriminator.prototype.encode = function (src, b, offset) {\r\n        return this.layout.encode(src, b, offset);\r\n    };\r\n    return UnionLayoutDiscriminator;\r\n}(UnionDiscriminator));\r\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\r\n/**\r\n * Represent any number of span-compatible layouts.\r\n *\r\n * *Factory*: {@link module:Layout.union|union}\r\n *\r\n * If the union has a {@link Union#defaultLayout|default layout} that\r\n * layout must have a non-negative {@link Layout#span|span}.  The span\r\n * of a fixed-span union includes its {@link\r\n * Union#discriminator|discriminator} if the variant is a {@link\r\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\r\n * of its {@link Union#defaultLayout|default layout}.\r\n *\r\n * If the union does not have a default layout then the encoded span\r\n * of the union depends on the encoded span of its variant (which may\r\n * be fixed or variable).\r\n *\r\n * {@link VariantLayout#layout|Variant layout}s are added through\r\n * {@link Union#addVariant|addVariant}.  If the union has a default\r\n * layout, the span of the {@link VariantLayout#layout|layout\r\n * contained by the variant} must not exceed the span of the {@link\r\n * Union#defaultLayout|default layout} (minus the span of a {@link\r\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\r\n * span of the variant will equal the span of the union itself.\r\n *\r\n * The variant for a buffer can only be identified from the {@link\r\n * Union#discriminator|discriminator} {@link\r\n * UnionDiscriminator#property|property} (in the case of the {@link\r\n * Union#defaultLayout|default layout}), or by using {@link\r\n * Union#getVariant|getVariant} and examining the resulting {@link\r\n * VariantLayout} instance.\r\n *\r\n * A variant compatible with a JavaScript object can be identified\r\n * using {@link Union#getSourceVariant|getSourceVariant}.\r\n *\r\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\r\n * identify the layout used to interpret the union contents.  The\r\n * parameter must be an instance of {@link UnionDiscriminator}, an\r\n * {@link ExternalLayout} that satisfies {@link\r\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\r\n * UIntBE}).  When a non-external layout element is passed the layout\r\n * appears at the start of the union.  In all cases the (synthesized)\r\n * {@link UnionDiscriminator} instance is recorded as {@link\r\n * Union#discriminator|discriminator}.\r\n *\r\n * @param {(Layout|null)} defaultLayout - initializer for {@link\r\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\r\n * If `null` there is no default layout: the union has data-dependent\r\n * length and attempts to decode or encode unrecognized variants will\r\n * throw an exception.  A {@link Layout} instance must have a\r\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\r\n * Layout#property|property} the {@link\r\n * Union#defaultLayout|defaultLayout} will be a {@link\r\n * Layout#replicate|replica} with property `content`.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar Union = /** @class */ (function (_super) {\r\n    __extends(Union, _super);\r\n    function Union(discr, defaultLayout, property) {\r\n        var _this = this;\r\n        var upv = ((discr instanceof UInt)\r\n            || (discr instanceof UIntBE));\r\n        var discriminator;\r\n        if (upv) {\r\n            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\r\n        }\r\n        else if ((discr instanceof ExternalLayout)\r\n            && discr.isCount()) {\r\n            discriminator = new UnionLayoutDiscriminator(discr);\r\n        }\r\n        else if (!(discr instanceof UnionDiscriminator)) {\r\n            throw new TypeError('discr must be a UnionDiscriminator '\r\n                + 'or an unsigned integer layout');\r\n        }\r\n        else {\r\n            discriminator = discr;\r\n        }\r\n        if (undefined === defaultLayout) {\r\n            defaultLayout = null;\r\n        }\r\n        if (!((null === defaultLayout)\r\n            || (defaultLayout instanceof Layout))) {\r\n            throw new TypeError('defaultLayout must be null or a Layout');\r\n        }\r\n        if (null !== defaultLayout) {\r\n            if (0 > defaultLayout.span) {\r\n                throw new Error('defaultLayout must have constant span');\r\n            }\r\n            if (undefined === defaultLayout.property) {\r\n                defaultLayout = defaultLayout.replicate('content');\r\n            }\r\n        }\r\n        /* The union span can be estimated only if there's a default\r\n         * layout.  The union spans its default layout, plus any prefix\r\n         * variant layout.  By construction both layouts, if present, have\r\n         * non-negative span. */\r\n        var span = -1;\r\n        if (defaultLayout) {\r\n            span = defaultLayout.span;\r\n            if ((0 <= span) && upv) {\r\n                span += discriminator.layout.span;\r\n            }\r\n        }\r\n        _this = _super.call(this, span, property) || this;\r\n        /** The interface for the discriminator value in isolation.\r\n         *\r\n         * This a {@link UnionDiscriminator} either passed to the\r\n         * constructor or synthesized from the `discr` constructor\r\n         * argument.  {@link\r\n         * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\r\n         * `true` iff the `discr` parameter was a non-offset {@link\r\n         * Layout} instance. */\r\n        _this.discriminator = discriminator;\r\n        /** `true` if the {@link Union#discriminator|discriminator} is the\r\n         * first field in the union.\r\n         *\r\n         * If `false` the discriminator is obtained from somewhere\r\n         * else. */\r\n        _this.usesPrefixDiscriminator = upv;\r\n        /** The layout for non-discriminator content when the value of the\r\n         * discriminator is not recognized.\r\n         *\r\n         * This is the value passed to the constructor.  It is\r\n         * structurally equivalent to the second component of {@link\r\n         * Union#layout|layout} but may have a different property\r\n         * name. */\r\n        _this.defaultLayout = defaultLayout;\r\n        /** A registry of allowed variants.\r\n         *\r\n         * The keys are unsigned integers which should be compatible with\r\n         * {@link Union.discriminator|discriminator}.  The property value\r\n         * is the corresponding {@link VariantLayout} instances assigned\r\n         * to this union by {@link Union#addVariant|addVariant}.\r\n         *\r\n         * **NOTE** The registry remains mutable so that variants can be\r\n         * {@link Union#addVariant|added} at any time.  Users should not\r\n         * manipulate the content of this property. */\r\n        _this.registry = {};\r\n        /* Private variable used when invoking getSourceVariant */\r\n        var boundGetSourceVariant = _this.defaultGetSourceVariant.bind(_this);\r\n        /** Function to infer the variant selected by a source object.\r\n         *\r\n         * Defaults to {@link\r\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\r\n         * be overridden using {@link\r\n         * Union#configGetSourceVariant|configGetSourceVariant}.\r\n         *\r\n         * @param {Object} src - as with {@link\r\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\r\n         *\r\n         * @returns {(undefined|VariantLayout)} The default variant\r\n         * (`undefined`) or first registered variant that uses a property\r\n         * available in `src`. */\r\n        _this.getSourceVariant = function (src) {\r\n            return boundGetSourceVariant(src);\r\n        };\r\n        /** Function to override the implementation of {@link\r\n         * Union#getSourceVariant|getSourceVariant}.\r\n         *\r\n         * Use this if the desired variant cannot be identified using the\r\n         * algorithm of {@link\r\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\r\n         *\r\n         * **NOTE** The provided function will be invoked bound to this\r\n         * Union instance, providing local access to {@link\r\n         * Union#registry|registry}.\r\n         *\r\n         * @param {Function} gsv - a function that follows the API of\r\n         * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\r\n        _this.configGetSourceVariant = function (gsv) {\r\n            boundGetSourceVariant = gsv.bind(this);\r\n        };\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    Union.prototype.getSpan = function (b, offset) {\r\n        if (0 <= this.span) {\r\n            return this.span;\r\n        }\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        /* Default layouts always have non-negative span, so we don't have\r\n         * one and we have to recognize the variant which will in turn\r\n         * determine the span. */\r\n        var vlo = this.getVariant(b, offset);\r\n        if (!vlo) {\r\n            throw new Error('unable to determine span for unrecognized variant');\r\n        }\r\n        return vlo.getSpan(b, offset);\r\n    };\r\n    /**\r\n     * Method to infer a registered Union variant compatible with `src`.\r\n     *\r\n     * The first satisfied rule in the following sequence defines the\r\n     * return value:\r\n     * * If `src` has properties matching the Union discriminator and\r\n     *   the default layout, `undefined` is returned regardless of the\r\n     *   value of the discriminator property (this ensures the default\r\n     *   layout will be used);\r\n     * * If `src` has a property matching the Union discriminator, the\r\n     *   value of the discriminator identifies a registered variant, and\r\n     *   either (a) the variant has no layout, or (b) `src` has the\r\n     *   variant's property, then the variant is returned (because the\r\n     *   source satisfies the constraints of the variant it identifies);\r\n     * * If `src` does not have a property matching the Union\r\n     *   discriminator, but does have a property matching a registered\r\n     *   variant, then the variant is returned (because the source\r\n     *   matches a variant without an explicit conflict);\r\n     * * An error is thrown (because we either can't identify a variant,\r\n     *   or we were explicitly told the variant but can't satisfy it).\r\n     *\r\n     * @param {Object} src - an object presumed to be compatible with\r\n     * the content of the Union.\r\n     *\r\n     * @return {(undefined|VariantLayout)} - as described above.\r\n     *\r\n     * @throws {Error} - if `src` cannot be associated with a default or\r\n     * registered variant.\r\n     */\r\n    Union.prototype.defaultGetSourceVariant = function (src) {\r\n        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\r\n            if (this.defaultLayout && this.defaultLayout.property\r\n                && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\r\n                return undefined;\r\n            }\r\n            var vlo = this.registry[src[this.discriminator.property]];\r\n            if (vlo\r\n                && ((!vlo.layout)\r\n                    || (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)))) {\r\n                return vlo;\r\n            }\r\n        }\r\n        else {\r\n            for (var tag in this.registry) {\r\n                var vlo = this.registry[tag];\r\n                if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\r\n                    return vlo;\r\n                }\r\n            }\r\n        }\r\n        throw new Error('unable to infer src variant');\r\n    };\r\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\r\n     *\r\n     * If the variant is {@link Union#addVariant|registered} the return\r\n     * value is an instance of that variant, with no explicit\r\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\r\n     * layout} is used to decode the content. */\r\n    Union.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var dest;\r\n        var dlo = this.discriminator;\r\n        var discr = dlo.decode(b, offset);\r\n        var clo = this.registry[discr];\r\n        if (undefined === clo) {\r\n            var defaultLayout = this.defaultLayout;\r\n            var contentOffset = 0;\r\n            if (this.usesPrefixDiscriminator) {\r\n                contentOffset = dlo.layout.span;\r\n            }\r\n            dest = this.makeDestinationObject();\r\n            dest[dlo.property] = discr;\r\n            dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\r\n        }\r\n        else {\r\n            dest = clo.decode(b, offset);\r\n        }\r\n        return dest;\r\n    };\r\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\r\n     *\r\n     * This API assumes the `src` object is consistent with the union's\r\n     * {@link Union#defaultLayout|default layout}.  To encode variants\r\n     * use the appropriate variant-specific {@link VariantLayout#encode}\r\n     * method. */\r\n    Union.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var vlo = this.getSourceVariant(src);\r\n        if (undefined === vlo) {\r\n            var dlo = this.discriminator;\r\n            // this.defaultLayout is not undefined when vlo is undefined\r\n            var clo = this.defaultLayout;\r\n            var contentOffset = 0;\r\n            if (this.usesPrefixDiscriminator) {\r\n                contentOffset = dlo.layout.span;\r\n            }\r\n            dlo.encode(src[dlo.property], b, offset);\r\n            // clo.property is not undefined when vlo is undefined\r\n            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\r\n        }\r\n        return vlo.encode(src, b, offset);\r\n    };\r\n    /** Register a new variant structure within a union.  The newly\r\n     * created variant is returned.\r\n     *\r\n     * @param {Number} variant - initializer for {@link\r\n     * VariantLayout#variant|variant}.\r\n     *\r\n     * @param {Layout} layout - initializer for {@link\r\n     * VariantLayout#layout|layout}.\r\n     *\r\n     * @param {String} property - initializer for {@link\r\n     * Layout#property|property}.\r\n     *\r\n     * @return {VariantLayout} */\r\n    Union.prototype.addVariant = function (variant, layout, property) {\r\n        var rv = new VariantLayout(this, variant, layout, property);\r\n        this.registry[variant] = rv;\r\n        return rv;\r\n    };\r\n    /**\r\n     * Get the layout associated with a registered variant.\r\n     *\r\n     * If `vb` does not produce a registered variant the function returns\r\n     * `undefined`.\r\n     *\r\n     * @param {(Number|Uint8Array)} vb - either the variant number, or a\r\n     * buffer from which the discriminator is to be read.\r\n     *\r\n     * @param {Number} offset - offset into `vb` for the start of the\r\n     * union.  Used only when `vb` is an instance of {Uint8Array}.\r\n     *\r\n     * @return {({VariantLayout}|undefined)}\r\n     */\r\n    Union.prototype.getVariant = function (vb, offset) {\r\n        var variant;\r\n        if (vb instanceof Uint8Array) {\r\n            if (undefined === offset) {\r\n                offset = 0;\r\n            }\r\n            variant = this.discriminator.decode(vb, offset);\r\n        }\r\n        else {\r\n            variant = vb;\r\n        }\r\n        return this.registry[variant];\r\n    };\r\n    return Union;\r\n}(Layout));\r\nexports.Union = Union;\r\n/**\r\n * Represent a specific variant within a containing union.\r\n *\r\n * **NOTE** The {@link Layout#span|span} of the variant may include\r\n * the span of the {@link Union#discriminator|discriminator} used to\r\n * identify it, but values read and written using the variant strictly\r\n * conform to the content of {@link VariantLayout#layout|layout}.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.  Use\r\n * the union {@link Union#addVariant|addVariant} helper method.\r\n *\r\n * @param {Union} union - initializer for {@link\r\n * VariantLayout#union|union}.\r\n *\r\n * @param {Number} variant - initializer for {@link\r\n * VariantLayout#variant|variant}.\r\n *\r\n * @param {Layout} [layout] - initializer for {@link\r\n * VariantLayout#layout|layout}.  If absent the variant carries no\r\n * data.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.  Unlike many other layouts, variant\r\n * layouts normally include a property name so they can be identified\r\n * within their containing {@link Union}.  The property identifier may\r\n * be absent only if `layout` is is absent.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar VariantLayout = /** @class */ (function (_super) {\r\n    __extends(VariantLayout, _super);\r\n    function VariantLayout(union, variant, layout, property) {\r\n        var _this = this;\r\n        if (!(union instanceof Union)) {\r\n            throw new TypeError('union must be a Union');\r\n        }\r\n        if ((!Number.isInteger(variant)) || (0 > variant)) {\r\n            throw new TypeError('variant must be a (non-negative) integer');\r\n        }\r\n        if (('string' === typeof layout)\r\n            && (undefined === property)) {\r\n            property = layout;\r\n            layout = null;\r\n        }\r\n        if (layout) {\r\n            if (!(layout instanceof Layout)) {\r\n                throw new TypeError('layout must be a Layout');\r\n            }\r\n            if ((null !== union.defaultLayout)\r\n                && (0 <= layout.span)\r\n                && (layout.span > union.defaultLayout.span)) {\r\n                throw new Error('variant span exceeds span of containing union');\r\n            }\r\n            if ('string' !== typeof property) {\r\n                throw new TypeError('variant must have a String property');\r\n            }\r\n        }\r\n        var span = union.span;\r\n        if (0 > union.span) {\r\n            span = layout ? layout.span : 0;\r\n            if ((0 <= span) && union.usesPrefixDiscriminator) {\r\n                span += union.discriminator.layout.span;\r\n            }\r\n        }\r\n        _this = _super.call(this, span, property) || this;\r\n        /** The {@link Union} to which this variant belongs. */\r\n        _this.union = union;\r\n        /** The unsigned integral value identifying this variant within\r\n         * the {@link Union#discriminator|discriminator} of the containing\r\n         * union. */\r\n        _this.variant = variant;\r\n        /** The {@link Layout} to be used when reading/writing the\r\n         * non-discriminator part of the {@link\r\n         * VariantLayout#union|union}.  If `null` the variant carries no\r\n         * data. */\r\n        _this.layout = layout || null;\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    VariantLayout.prototype.getSpan = function (b, offset) {\r\n        if (0 <= this.span) {\r\n            /* Will be equal to the containing union span if that is not\r\n             * variable. */\r\n            return this.span;\r\n        }\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var contentOffset = 0;\r\n        if (this.union.usesPrefixDiscriminator) {\r\n            contentOffset = this.union.discriminator.layout.span;\r\n        }\r\n        /* Span is defined solely by the variant (and prefix discriminator) */\r\n        var span = 0;\r\n        if (this.layout) {\r\n            span = this.layout.getSpan(b, offset + contentOffset);\r\n        }\r\n        return contentOffset + span;\r\n    };\r\n    /** @override */\r\n    VariantLayout.prototype.decode = function (b, offset) {\r\n        var dest = this.makeDestinationObject();\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        if (this !== this.union.getVariant(b, offset)) {\r\n            throw new Error('variant mismatch');\r\n        }\r\n        var contentOffset = 0;\r\n        if (this.union.usesPrefixDiscriminator) {\r\n            contentOffset = this.union.discriminator.layout.span;\r\n        }\r\n        // VariantLayout property is never undefined\r\n        var property = this.property;\r\n        if (this.layout) {\r\n            dest[property] = this.layout.decode(b, offset + contentOffset);\r\n        }\r\n        else if (property) {\r\n            dest[property] = true;\r\n        }\r\n        else if (this.union.usesPrefixDiscriminator) {\r\n            dest[this.union.discriminator.property] = this.variant;\r\n        }\r\n        return dest;\r\n    };\r\n    /** @override */\r\n    VariantLayout.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var contentOffset = 0;\r\n        if (this.union.usesPrefixDiscriminator) {\r\n            contentOffset = this.union.discriminator.layout.span;\r\n        }\r\n        // VariantLayout property is never undefined\r\n        var property = this.property;\r\n        if (this.layout\r\n            && (!Object.prototype.hasOwnProperty.call(src, property))) {\r\n            throw new TypeError('variant lacks property ' + property);\r\n        }\r\n        this.union.discriminator.encode(this.variant, b, offset);\r\n        var span = contentOffset;\r\n        if (this.layout) {\r\n            this.layout.encode(src[property], b, offset + contentOffset);\r\n            span += this.layout.getSpan(b, offset + contentOffset);\r\n            if ((0 <= this.union.span)\r\n                && (span > this.union.span)) {\r\n                throw new Error('encoded variant overruns containing union');\r\n            }\r\n        }\r\n        return span;\r\n    };\r\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\r\n     * VariantLayout#layout|layout}. */\r\n    VariantLayout.prototype.fromArray = function (values) {\r\n        if (this.layout) {\r\n            return this.layout.fromArray(values);\r\n        }\r\n        return undefined;\r\n    };\r\n    return VariantLayout;\r\n}(Layout));\r\nexports.VariantLayout = VariantLayout;\r\n/** JavaScript chose to define bitwise operations as operating on\r\n * signed 32-bit values in 2's complement form, meaning any integer\r\n * with bit 31 set is going to look negative.  For right shifts that's\r\n * not a problem, because `>>>` is a logical shift, but for every\r\n * other bitwise operator we have to compensate for possible negative\r\n * results. */\r\nfunction fixBitwiseResult(v) {\r\n    if (0 > v) {\r\n        v += 0x100000000;\r\n    }\r\n    return v;\r\n}\r\n/**\r\n * Contain a sequence of bit fields as an unsigned integer.\r\n *\r\n * *Factory*: {@link module:Layout.bits|bits}\r\n *\r\n * This is a container element; within it there are {@link BitField}\r\n * instances that provide the extracted properties.  The container\r\n * simply defines the aggregate representation and its bit ordering.\r\n * The representation is an object containing properties with numeric\r\n * or {@link Boolean} values.\r\n *\r\n * {@link BitField}s are added with the {@link\r\n * BitStructure#addField|addField} and {@link\r\n * BitStructure#addBoolean|addBoolean} methods.\r\n\r\n * @param {Layout} word - initializer for {@link\r\n * BitStructure#word|word}.  The parameter must be an instance of\r\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\r\n *\r\n * @param {bool} [msb] - `true` if the bit numbering starts at the\r\n * most significant bit of the containing word; `false` (default) if\r\n * it starts at the least significant bit of the containing word.  If\r\n * the parameter at this position is a string and `property` is\r\n * `undefined` the value of this argument will instead be used as the\r\n * value of `property`.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar BitStructure = /** @class */ (function (_super) {\r\n    __extends(BitStructure, _super);\r\n    function BitStructure(word, msb, property) {\r\n        var _this = this;\r\n        if (!((word instanceof UInt)\r\n            || (word instanceof UIntBE))) {\r\n            throw new TypeError('word must be a UInt or UIntBE layout');\r\n        }\r\n        if (('string' === typeof msb)\r\n            && (undefined === property)) {\r\n            property = msb;\r\n            msb = false;\r\n        }\r\n        if (4 < word.span) {\r\n            throw new RangeError('word cannot exceed 32 bits');\r\n        }\r\n        _this = _super.call(this, word.span, property) || this;\r\n        /** The layout used for the packed value.  {@link BitField}\r\n         * instances are packed sequentially depending on {@link\r\n         * BitStructure#msb|msb}. */\r\n        _this.word = word;\r\n        /** Whether the bit sequences are packed starting at the most\r\n         * significant bit growing down (`true`), or the least significant\r\n         * bit growing up (`false`).\r\n         *\r\n         * **NOTE** Regardless of this value, the least significant bit of\r\n         * any {@link BitField} value is the least significant bit of the\r\n         * corresponding section of the packed value. */\r\n        _this.msb = !!msb;\r\n        /** The sequence of {@link BitField} layouts that comprise the\r\n         * packed structure.\r\n         *\r\n         * **NOTE** The array remains mutable to allow fields to be {@link\r\n         * BitStructure#addField|added} after construction.  Users should\r\n         * not manipulate the content of this property.*/\r\n        _this.fields = [];\r\n        /* Storage for the value.  Capture a variable instead of using an\r\n         * instance property because we don't want anything to change the\r\n         * value without going through the mutator. */\r\n        var value = 0;\r\n        _this._packedSetValue = function (v) {\r\n            value = fixBitwiseResult(v);\r\n            return this;\r\n        };\r\n        _this._packedGetValue = function () {\r\n            return value;\r\n        };\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    BitStructure.prototype.decode = function (b, offset) {\r\n        var dest = this.makeDestinationObject();\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var value = this.word.decode(b, offset);\r\n        this._packedSetValue(value);\r\n        for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\r\n            var fd = _a[_i];\r\n            if (undefined !== fd.property) {\r\n                dest[fd.property] = fd.decode(value);\r\n            }\r\n        }\r\n        return dest;\r\n    };\r\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\r\n     *\r\n     * If `src` is missing a property for a member with a defined {@link\r\n     * Layout#property|property} the corresponding region of the packed\r\n     * value is left unmodified.  Unused bits are also left unmodified. */\r\n    BitStructure.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var value = this.word.decode(b, offset);\r\n        this._packedSetValue(value);\r\n        for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\r\n            var fd = _a[_i];\r\n            if (undefined !== fd.property) {\r\n                var fv = src[fd.property];\r\n                if (undefined !== fv) {\r\n                    fd.encode(fv);\r\n                }\r\n            }\r\n        }\r\n        return this.word.encode(this._packedGetValue(), b, offset);\r\n    };\r\n    /** Register a new bitfield with a containing bit structure.  The\r\n     * resulting bitfield is returned.\r\n     *\r\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\r\n     *\r\n     * @param {string} property - initializer for {@link\r\n     * Layout#property|property}.\r\n     *\r\n     * @return {BitField} */\r\n    BitStructure.prototype.addField = function (bits, property) {\r\n        var bf = new BitField(this, bits, property);\r\n        this.fields.push(bf);\r\n        return bf;\r\n    };\r\n    /** As with {@link BitStructure#addField|addField} for single-bit\r\n     * fields with `boolean` value representation.\r\n     *\r\n     * @param {string} property - initializer for {@link\r\n     * Layout#property|property}.\r\n     *\r\n     * @return {Boolean} */\r\n    BitStructure.prototype.addBoolean = function (property) {\r\n        // This is my Boolean, not the Javascript one.\r\n        // eslint-disable-next-line no-new-wrappers\r\n        var bf = new Boolean(this, property);\r\n        this.fields.push(bf);\r\n        return bf;\r\n    };\r\n    /**\r\n     * Get access to the bit field for a given property.\r\n     *\r\n     * @param {String} property - the bit field of interest.\r\n     *\r\n     * @return {BitField} - the field associated with `property`, or\r\n     * undefined if there is no such property.\r\n     */\r\n    BitStructure.prototype.fieldFor = function (property) {\r\n        if ('string' !== typeof property) {\r\n            throw new TypeError('property must be string');\r\n        }\r\n        for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\r\n            var fd = _a[_i];\r\n            if (fd.property === property) {\r\n                return fd;\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    return BitStructure;\r\n}(Layout));\r\nexports.BitStructure = BitStructure;\r\n/**\r\n * Represent a sequence of bits within a {@link BitStructure}.\r\n *\r\n * All bit field values are represented as unsigned integers.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.\r\n * Use the container {@link BitStructure#addField|addField} helper\r\n * method.\r\n *\r\n * **NOTE** BitField instances are not instances of {@link Layout}\r\n * since {@link Layout#span|span} measures 8-bit units.\r\n *\r\n * @param {BitStructure} container - initializer for {@link\r\n * BitField#container|container}.\r\n *\r\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n */\r\nvar BitField = /** @class */ (function () {\r\n    function BitField(container, bits, property) {\r\n        if (!(container instanceof BitStructure)) {\r\n            throw new TypeError('container must be a BitStructure');\r\n        }\r\n        if ((!Number.isInteger(bits)) || (0 >= bits)) {\r\n            throw new TypeError('bits must be positive integer');\r\n        }\r\n        var totalBits = 8 * container.span;\r\n        var usedBits = container.fields.reduce(function (sum, fd) { return sum + fd.bits; }, 0);\r\n        if ((bits + usedBits) > totalBits) {\r\n            throw new Error('bits too long for span remainder ('\r\n                + (totalBits - usedBits) + ' of '\r\n                + totalBits + ' remain)');\r\n        }\r\n        /** The {@link BitStructure} instance to which this bit field\r\n         * belongs. */\r\n        this.container = container;\r\n        /** The span of this value in bits. */\r\n        this.bits = bits;\r\n        /** A mask of {@link BitField#bits|bits} bits isolating value bits\r\n         * that fit within the field.\r\n         *\r\n         * That is, it masks a value that has not yet been shifted into\r\n         * position within its containing packed integer. */\r\n        this.valueMask = (1 << bits) - 1;\r\n        if (32 === bits) { // shifted value out of range\r\n            this.valueMask = 0xFFFFFFFF;\r\n        }\r\n        /** The offset of the value within the containing packed unsigned\r\n         * integer.  The least significant bit of the packed value is at\r\n         * offset zero, regardless of bit ordering used. */\r\n        this.start = usedBits;\r\n        if (this.container.msb) {\r\n            this.start = totalBits - usedBits - bits;\r\n        }\r\n        /** A mask of {@link BitField#bits|bits} isolating the field value\r\n         * within the containing packed unsigned integer. */\r\n        this.wordMask = fixBitwiseResult(this.valueMask << this.start);\r\n        /** The property name used when this bitfield is represented in an\r\n         * Object.\r\n         *\r\n         * Intended to be functionally equivalent to {@link\r\n         * Layout#property}.\r\n         *\r\n         * If left undefined the corresponding span of bits will be\r\n         * treated as padding: it will not be mutated by {@link\r\n         * Layout#encode|encode} nor represented as a property in the\r\n         * decoded Object. */\r\n        this.property = property;\r\n    }\r\n    /** Store a value into the corresponding subsequence of the containing\r\n     * bit field. */\r\n    BitField.prototype.decode = function (b, offset) {\r\n        var word = this.container._packedGetValue();\r\n        var wordValue = fixBitwiseResult(word & this.wordMask);\r\n        var value = wordValue >>> this.start;\r\n        return value;\r\n    };\r\n    /** Store a value into the corresponding subsequence of the containing\r\n     * bit field.\r\n     *\r\n     * **NOTE** This is not a specialization of {@link\r\n     * Layout#encode|Layout.encode} and there is no return value. */\r\n    BitField.prototype.encode = function (value) {\r\n        if ((!Number.isInteger(value))\r\n            || (value !== fixBitwiseResult(value & this.valueMask))) {\r\n            throw new TypeError(nameWithProperty('BitField.encode', this)\r\n                + ' value must be integer not exceeding ' + this.valueMask);\r\n        }\r\n        var word = this.container._packedGetValue();\r\n        var wordValue = fixBitwiseResult(value << this.start);\r\n        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)\r\n            | wordValue);\r\n    };\r\n    return BitField;\r\n}());\r\nexports.BitField = BitField;\r\n/**\r\n * Represent a single bit within a {@link BitStructure} as a\r\n * JavaScript boolean.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.\r\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\r\n * method.\r\n *\r\n * @param {BitStructure} container - initializer for {@link\r\n * BitField#container|container}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {BitField}\r\n */\r\n/* eslint-disable no-extend-native */\r\nvar Boolean = /** @class */ (function (_super) {\r\n    __extends(Boolean, _super);\r\n    function Boolean(container, property) {\r\n        return _super.call(this, container, 1, property) || this;\r\n    }\r\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\r\n     *\r\n     * @returns {boolean} */\r\n    Boolean.prototype.decode = function (b, offset) {\r\n        return !!BitField.prototype.decode.call(this, b, offset);\r\n    };\r\n    /** @override */\r\n    Boolean.prototype.encode = function (value) {\r\n        if ('boolean' === typeof value) {\r\n            // BitField requires integer values\r\n            value = +value;\r\n        }\r\n        return BitField.prototype.encode.call(this, value);\r\n    };\r\n    return Boolean;\r\n}(BitField));\r\nexports.Boolean = Boolean;\r\n/* eslint-enable no-extend-native */\r\n/**\r\n * Contain a fixed-length block of arbitrary data, represented as a\r\n * Uint8Array.\r\n *\r\n * *Factory*: {@link module:Layout.blob|blob}\r\n *\r\n * @param {(Number|ExternalLayout)} length - initializes {@link\r\n * Blob#length|length}.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar Blob = /** @class */ (function (_super) {\r\n    __extends(Blob, _super);\r\n    function Blob(length, property) {\r\n        var _this = this;\r\n        if (!(((length instanceof ExternalLayout) && length.isCount())\r\n            || (Number.isInteger(length) && (0 <= length)))) {\r\n            throw new TypeError('length must be positive integer '\r\n                + 'or an unsigned integer ExternalLayout');\r\n        }\r\n        var span = -1;\r\n        if (!(length instanceof ExternalLayout)) {\r\n            span = length;\r\n        }\r\n        _this = _super.call(this, span, property) || this;\r\n        /** The number of bytes in the blob.\r\n         *\r\n         * This may be a non-negative integer, or an instance of {@link\r\n         * ExternalLayout} that satisfies {@link\r\n         * ExternalLayout#isCount|isCount()}. */\r\n        _this.length = length;\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    Blob.prototype.getSpan = function (b, offset) {\r\n        var span = this.span;\r\n        if (0 > span) {\r\n            span = this.length.decode(b, offset);\r\n        }\r\n        return span;\r\n    };\r\n    /** @override */\r\n    Blob.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var span = this.span;\r\n        if (0 > span) {\r\n            span = this.length.decode(b, offset);\r\n        }\r\n        return uint8ArrayToBuffer(b).slice(offset, offset + span);\r\n    };\r\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\r\n     *\r\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\r\n     * ExternalLayout} then the length of `src` will be encoded as the\r\n     * count after `src` is encoded. */\r\n    Blob.prototype.encode = function (src, b, offset) {\r\n        var span = this.length;\r\n        if (this.length instanceof ExternalLayout) {\r\n            span = src.length;\r\n        }\r\n        if (!(src instanceof Uint8Array && span === src.length)) {\r\n            throw new TypeError(nameWithProperty('Blob.encode', this)\r\n                + ' requires (length ' + span + ') Uint8Array as src');\r\n        }\r\n        if ((offset + span) > b.length) {\r\n            throw new RangeError('encoding overruns Uint8Array');\r\n        }\r\n        var srcBuffer = uint8ArrayToBuffer(src);\r\n        uint8ArrayToBuffer(b).write(srcBuffer.toString('hex'), offset, span, 'hex');\r\n        if (this.length instanceof ExternalLayout) {\r\n            this.length.encode(span, b, offset);\r\n        }\r\n        return span;\r\n    };\r\n    return Blob;\r\n}(Layout));\r\nexports.Blob = Blob;\r\n/**\r\n * Contain a `NUL`-terminated UTF8 string.\r\n *\r\n * *Factory*: {@link module:Layout.cstr|cstr}\r\n *\r\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\r\n * not be correctly decoded by this layout.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar CString = /** @class */ (function (_super) {\r\n    __extends(CString, _super);\r\n    function CString(property) {\r\n        return _super.call(this, -1, property) || this;\r\n    }\r\n    /** @override */\r\n    CString.prototype.getSpan = function (b, offset) {\r\n        checkUint8Array(b);\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var idx = offset;\r\n        while ((idx < b.length) && (0 !== b[idx])) {\r\n            idx += 1;\r\n        }\r\n        return 1 + idx - offset;\r\n    };\r\n    /** @override */\r\n    CString.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var span = this.getSpan(b, offset);\r\n        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString('utf-8');\r\n    };\r\n    /** @override */\r\n    CString.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        /* Must force this to a string, lest it be a number and the\r\n         * \"utf8-encoding\" below actually allocate a buffer of length\r\n         * src */\r\n        if ('string' !== typeof src) {\r\n            src = src.toString();\r\n        }\r\n        var srcb = buffer_1.Buffer.from(src, 'utf8');\r\n        var span = srcb.length;\r\n        if ((offset + span) > b.length) {\r\n            throw new RangeError('encoding overruns Buffer');\r\n        }\r\n        var buffer = uint8ArrayToBuffer(b);\r\n        srcb.copy(buffer, offset);\r\n        buffer[offset + span] = 0;\r\n        return span + 1;\r\n    };\r\n    return CString;\r\n}(Layout));\r\nexports.CString = CString;\r\n/**\r\n * Contain a UTF8 string with implicit length.\r\n *\r\n * *Factory*: {@link module:Layout.utf8|utf8}\r\n *\r\n * **NOTE** Because the length is implicit in the size of the buffer\r\n * this layout should be used only in isolation, or in a situation\r\n * where the length can be expressed by operating on a slice of the\r\n * containing buffer.\r\n *\r\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\r\n * string content.  If not provided there is no bound on the allowed\r\n * content.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar UTF8 = /** @class */ (function (_super) {\r\n    __extends(UTF8, _super);\r\n    function UTF8(maxSpan, property) {\r\n        var _this = this;\r\n        if (('string' === typeof maxSpan) && (undefined === property)) {\r\n            property = maxSpan;\r\n            maxSpan = undefined;\r\n        }\r\n        if (undefined === maxSpan) {\r\n            maxSpan = -1;\r\n        }\r\n        else if (!Number.isInteger(maxSpan)) {\r\n            throw new TypeError('maxSpan must be an integer');\r\n        }\r\n        _this = _super.call(this, -1, property) || this;\r\n        /** The maximum span of the layout in bytes.\r\n         *\r\n         * Positive values are generally expected.  Zero is abnormal.\r\n         * Attempts to encode or decode a value that exceeds this length\r\n         * will throw a `RangeError`.\r\n         *\r\n         * A negative value indicates that there is no bound on the length\r\n         * of the content. */\r\n        _this.maxSpan = maxSpan;\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    UTF8.prototype.getSpan = function (b, offset) {\r\n        checkUint8Array(b);\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        return b.length - offset;\r\n    };\r\n    /** @override */\r\n    UTF8.prototype.decode = function (b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        var span = this.getSpan(b, offset);\r\n        if ((0 <= this.maxSpan)\r\n            && (this.maxSpan < span)) {\r\n            throw new RangeError('text length exceeds maxSpan');\r\n        }\r\n        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString('utf-8');\r\n    };\r\n    /** @override */\r\n    UTF8.prototype.encode = function (src, b, offset) {\r\n        if (undefined === offset) {\r\n            offset = 0;\r\n        }\r\n        /* Must force this to a string, lest it be a number and the\r\n         * \"utf8-encoding\" below actually allocate a buffer of length\r\n         * src */\r\n        if ('string' !== typeof src) {\r\n            src = src.toString();\r\n        }\r\n        var srcb = buffer_1.Buffer.from(src, 'utf8');\r\n        var span = srcb.length;\r\n        if ((0 <= this.maxSpan)\r\n            && (this.maxSpan < span)) {\r\n            throw new RangeError('text length exceeds maxSpan');\r\n        }\r\n        if ((offset + span) > b.length) {\r\n            throw new RangeError('encoding overruns Buffer');\r\n        }\r\n        srcb.copy(uint8ArrayToBuffer(b), offset);\r\n        return span;\r\n    };\r\n    return UTF8;\r\n}(Layout));\r\nexports.UTF8 = UTF8;\r\n/**\r\n * Contain a constant value.\r\n *\r\n * This layout may be used in cases where a JavaScript value can be\r\n * inferred without an expression in the binary encoding.  An example\r\n * would be a {@link VariantLayout|variant layout} where the content\r\n * is implied by the union {@link Union#discriminator|discriminator}.\r\n *\r\n * @param {Object|Number|String} value - initializer for {@link\r\n * Constant#value|value}.  If the value is an object (or array) and\r\n * the application intends the object to remain unchanged regardless\r\n * of what is done to values decoded by this layout, the value should\r\n * be frozen prior passing it to this constructor.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\r\nvar Constant = /** @class */ (function (_super) {\r\n    __extends(Constant, _super);\r\n    function Constant(value, property) {\r\n        var _this = _super.call(this, 0, property) || this;\r\n        /** The value produced by this constant when the layout is {@link\r\n         * Constant#decode|decoded}.\r\n         *\r\n         * Any JavaScript value including `null` and `undefined` is\r\n         * permitted.\r\n         *\r\n         * **WARNING** If `value` passed in the constructor was not\r\n         * frozen, it is possible for users of decoded values to change\r\n         * the content of the value. */\r\n        _this.value = value;\r\n        return _this;\r\n    }\r\n    /** @override */\r\n    Constant.prototype.decode = function (b, offset) {\r\n        return this.value;\r\n    };\r\n    /** @override */\r\n    Constant.prototype.encode = function (src, b, offset) {\r\n        /* Constants take no space */\r\n        return 0;\r\n    };\r\n    return Constant;\r\n}(Layout));\r\nexports.Constant = Constant;\r\n/** Factory for {@link GreedyCount}. */\r\nexports.greedy = (function (elementSpan, property) { return new GreedyCount(elementSpan, property); });\r\n/** Factory for {@link OffsetLayout}. */\r\nexports.offset = (function (layout, offset, property) { return new OffsetLayout(layout, offset, property); });\r\n/** Factory for {@link UInt|unsigned int layouts} spanning one\r\n * byte. */\r\nexports.u8 = (function (property) { return new UInt(1, property); });\r\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning two bytes. */\r\nexports.u16 = (function (property) { return new UInt(2, property); });\r\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning three bytes. */\r\nexports.u24 = (function (property) { return new UInt(3, property); });\r\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning four bytes. */\r\nexports.u32 = (function (property) { return new UInt(4, property); });\r\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning five bytes. */\r\nexports.u40 = (function (property) { return new UInt(5, property); });\r\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning six bytes. */\r\nexports.u48 = (function (property) { return new UInt(6, property); });\r\n/** Factory for {@link NearUInt64|little-endian unsigned int\r\n * layouts} interpreted as Numbers. */\r\nexports.nu64 = (function (property) { return new NearUInt64(property); });\r\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning two bytes. */\r\nexports.u16be = (function (property) { return new UIntBE(2, property); });\r\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning three bytes. */\r\nexports.u24be = (function (property) { return new UIntBE(3, property); });\r\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning four bytes. */\r\nexports.u32be = (function (property) { return new UIntBE(4, property); });\r\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning five bytes. */\r\nexports.u40be = (function (property) { return new UIntBE(5, property); });\r\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning six bytes. */\r\nexports.u48be = (function (property) { return new UIntBE(6, property); });\r\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\r\n * layouts} interpreted as Numbers. */\r\nexports.nu64be = (function (property) { return new NearUInt64BE(property); });\r\n/** Factory for {@link Int|signed int layouts} spanning one\r\n * byte. */\r\nexports.s8 = (function (property) { return new Int(1, property); });\r\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning two bytes. */\r\nexports.s16 = (function (property) { return new Int(2, property); });\r\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning three bytes. */\r\nexports.s24 = (function (property) { return new Int(3, property); });\r\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning four bytes. */\r\nexports.s32 = (function (property) { return new Int(4, property); });\r\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning five bytes. */\r\nexports.s40 = (function (property) { return new Int(5, property); });\r\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning six bytes. */\r\nexports.s48 = (function (property) { return new Int(6, property); });\r\n/** Factory for {@link NearInt64|little-endian signed int layouts}\r\n * interpreted as Numbers. */\r\nexports.ns64 = (function (property) { return new NearInt64(property); });\r\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning two bytes. */\r\nexports.s16be = (function (property) { return new IntBE(2, property); });\r\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning three bytes. */\r\nexports.s24be = (function (property) { return new IntBE(3, property); });\r\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning four bytes. */\r\nexports.s32be = (function (property) { return new IntBE(4, property); });\r\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning five bytes. */\r\nexports.s40be = (function (property) { return new IntBE(5, property); });\r\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning six bytes. */\r\nexports.s48be = (function (property) { return new IntBE(6, property); });\r\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\r\n * interpreted as Numbers. */\r\nexports.ns64be = (function (property) { return new NearInt64BE(property); });\r\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\r\nexports.f32 = (function (property) { return new Float(property); });\r\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\r\nexports.f32be = (function (property) { return new FloatBE(property); });\r\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\r\nexports.f64 = (function (property) { return new Double(property); });\r\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\r\nexports.f64be = (function (property) { return new DoubleBE(property); });\r\n/** Factory for {@link Structure} values. */\r\nexports.struct = (function (fields, property, decodePrefixes) {\r\n    return new Structure(fields, property, decodePrefixes);\r\n});\r\n/** Factory for {@link BitStructure} values. */\r\nexports.bits = (function (word, msb, property) { return new BitStructure(word, msb, property); });\r\n/** Factory for {@link Sequence} values. */\r\nexports.seq = (function (elementLayout, count, property) {\r\n    return new Sequence(elementLayout, count, property);\r\n});\r\n/** Factory for {@link Union} values. */\r\nexports.union = (function (discr, defaultLayout, property) {\r\n    return new Union(discr, defaultLayout, property);\r\n});\r\n/** Factory for {@link UnionLayoutDiscriminator} values. */\r\nexports.unionLayoutDiscriminator = (function (layout, property) { return new UnionLayoutDiscriminator(layout, property); });\r\n/** Factory for {@link Blob} values. */\r\nexports.blob = (function (length, property) { return new Blob(length, property); });\r\n/** Factory for {@link CString} values. */\r\nexports.cstr = (function (property) { return new CString(property); });\r\n/** Factory for {@link UTF8} values. */\r\nexports.utf8 = (function (maxSpan, property) { return new UTF8(maxSpan, property); });\r\n/** Factory for {@link Constant} values. */\r\nexports.constant = (function (value, property) { return new Constant(value, property); });\r\n//# sourceMappingURL=Layout.js.map"]},"metadata":{},"sourceType":"script"}